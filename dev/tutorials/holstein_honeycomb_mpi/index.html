<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1b) Honeycomb Holstein Model with MPI Parallelization · SmoQyElPhQMC.jl</title><meta name="title" content="1b) Honeycomb Holstein Model with MPI Parallelization · SmoQyElPhQMC.jl"/><meta property="og:title" content="1b) Honeycomb Holstein Model with MPI Parallelization · SmoQyElPhQMC.jl"/><meta property="twitter:title" content="1b) Honeycomb Holstein Model with MPI Parallelization · SmoQyElPhQMC.jl"/><meta name="description" content="Documentation for SmoQyElPhQMC.jl."/><meta property="og:description" content="Documentation for SmoQyElPhQMC.jl."/><meta property="twitter:description" content="Documentation for SmoQyElPhQMC.jl."/><meta property="og:url" content="https://SmoQySuite.github.io/SmoQyElPhQMC.jl/stable/tutorials/holstein_honeycomb_mpi/"/><meta property="twitter:url" content="https://SmoQySuite.github.io/SmoQyElPhQMC.jl/stable/tutorials/holstein_honeycomb_mpi/"/><link rel="canonical" href="https://SmoQySuite.github.io/SmoQyElPhQMC.jl/stable/tutorials/holstein_honeycomb_mpi/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SmoQyElPhQMC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../holstein_honeycomb/">1a) Honeycomb Holstein Model</a></li><li class="is-active"><a class="tocitem" href>1b) Honeycomb Holstein Model with MPI Parallelization</a><ul class="internal"><li><a class="tocitem" href="#Import-packages"><span>Import packages</span></a></li><li><a class="tocitem" href="#Specify-simulation-parameters"><span>Specify simulation parameters</span></a></li><li><a class="tocitem" href="#Initialize-simulation"><span>Initialize simulation</span></a></li><li><a class="tocitem" href="#Initialize-simulation-metadata"><span>Initialize simulation metadata</span></a></li><li><a class="tocitem" href="#Initialize-model"><span>Initialize model</span></a></li><li><a class="tocitem" href="#Initialize-model-parameters"><span>Initialize model parameters</span></a></li><li><a class="tocitem" href="#Initialize-measurements"><span>Initialize measurements</span></a></li><li><a class="tocitem" href="#Setup-QMC-simulation"><span>Setup QMC simulation</span></a></li><li><a class="tocitem" href="#Setup-EFA-PFF-HMC-Updates"><span>Setup EFA-PFF-HMC Updates</span></a></li><li><a class="tocitem" href="#Thermalize-system"><span>Thermalize system</span></a></li><li><a class="tocitem" href="#Make-measurements"><span>Make measurements</span></a></li><li><a class="tocitem" href="#Merge-binned-data"><span>Merge binned data</span></a></li><li><a class="tocitem" href="#Record-simulation-metadata"><span>Record simulation metadata</span></a></li><li><a class="tocitem" href="#Post-process-results"><span>Post-process results</span></a></li><li><a class="tocitem" href="#Execute-script"><span>Execute script</span></a></li></ul></li><li><a class="tocitem" href="../holstein_honeycomb_checkpoint/">1c) Honeycomb Holstein Model with Checkpointing</a></li><li><a class="tocitem" href="../holstein_honeycomb_density_tuning/">1d) Honeycomb Holstein Model with Density Tuning</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>1b) Honeycomb Holstein Model with MPI Parallelization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1b) Honeycomb Holstein Model with MPI Parallelization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SmoQySuite/SmoQyElPhQMC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SmoQySuite/SmoQyElPhQMC.jl/blob/main/tutorials/holstein_honeycomb_mpi.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Download this example as a <a href="../../assets/scripts/tutorials/holstein_honeycomb_mpi.jl">Julia script</a>.</p><h1 id="1b)-Honeycomb-Holstein-Model-with-MPI-Parallelization"><a class="docs-heading-anchor" href="#1b)-Honeycomb-Holstein-Model-with-MPI-Parallelization">1b) Honeycomb Holstein Model with MPI Parallelization</a><a id="1b)-Honeycomb-Holstein-Model-with-MPI-Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#1b)-Honeycomb-Holstein-Model-with-MPI-Parallelization" title="Permalink"></a></h1><p>This tutorial will build on the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial, demonstrating how to add parallelization with MPI using the <a href="https://github.com/JuliaParallel/MPI.jl.git">MPI.jl</a> package. By this we mean that each MPI process will act as independent walker, running it&#39;s own independent DQMC simulation, with the final reported estimates for measured quantities being the average across all walkers.</p><h2 id="Import-packages"><a class="docs-heading-anchor" href="#Import-packages">Import packages</a><a id="Import-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Import-packages" title="Permalink"></a></h2><p>We now need to import the <a href="https://github.com/JuliaParallel/MPI.jl.git">MPI.jl</a> package as well.</p><pre><code class="language-julia hljs">using SmoQyElPhQMC
using SmoQyDQMC
import SmoQyDQMC.LatticeUtilities as lu

using LinearAlgebra
using Random
using Printf
using MPI</code></pre><h2 id="Specify-simulation-parameters"><a class="docs-heading-anchor" href="#Specify-simulation-parameters">Specify simulation parameters</a><a id="Specify-simulation-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-simulation-parameters" title="Permalink"></a></h2><p>Here we have introduced the <code>comm</code> argument to the <code>run_simulation</code> function, which is a type exported by the <a href="https://github.com/JuliaParallel/MPI.jl.git">MPI.jl</a> package to facilitate communication and synchronization between the different MPI processes.</p><pre><code class="language-julia hljs"># Top-level function to run simulation.
function run_simulation(
    comm::MPI.Comm; # MPI communicator.
    # KEYWORD ARGUMENTS
    sID, # Simulation ID.
    Ω, # Phonon energy.
    α, # Electron-phonon coupling.
    μ, # Chemical potential.
    L, # System size.
    β, # Inverse temperature.
    N_therm, # Number of thermalization updates.
    N_measurements, # Total number of measurements.
    N_bins, # Number of times bin-averaged measurements are written to file.
    Δτ = 0.05, # Discretization in imaginary time.
    Nt = 24, # Number of time-steps in HMC update.
    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.
    tol = 1e-10, # CG iterations tolerance.
    maxiter = 10_000, # Maximum number of CG iterations.
    seed = abs(rand(Int)), # Seed for random number generator.
    filepath = &quot;.&quot; # Filepath to where data folder will be created.
)</code></pre><h2 id="Initialize-simulation"><a class="docs-heading-anchor" href="#Initialize-simulation">Initialize simulation</a><a id="Initialize-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation" title="Permalink"></a></h2><p>Now when initializing the <a href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/#SmoQyDQMC.SimulationInfo-Tuple%7B%7D"><code>SmoQyDQMC.SimulationInfo</code></a> type, we also need to include the MPI process ID <code>pID</code>, which can be retrieved using the <a href="https://juliaparallel.org/MPI.jl/stable/reference/comm/#MPI.Comm_rank"><code>MPI.Comm_rank</code></a> function.</p><p>We also the <a href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/#SmoQyDQMC.initialize_datafolder"><code>SmoQyDQMC.initialize_datafolder</code></a> function such that it takes the <code>comm</code> as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.</p><pre><code class="language-julia hljs">    # Construct the foldername the data will be written to.
    datafolder_prefix = @sprintf &quot;holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f&quot; Ω α μ L β

    # Get MPI process ID.
    pID = MPI.Comm_rank(comm)

    # Initialize simulation info.
    simulation_info = SimulationInfo(
        filepath = filepath,
        datafolder_prefix = datafolder_prefix,
        write_bins_concurrent = (L &gt; 7),
        sID = sID,
        pID = pID
    )

    # Initialize the directory the data will be written to.
    initialize_datafolder(comm, simulation_info)</code></pre><h2 id="Initialize-simulation-metadata"><a class="docs-heading-anchor" href="#Initialize-simulation-metadata">Initialize simulation metadata</a><a id="Initialize-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation-metadata" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Initialize random number generator
    rng = Xoshiro(seed)

    # Initialize metadata dictionary
    metadata = Dict()

    # Record simulation parameters.
    metadata[&quot;N_therm&quot;] = N_therm  # Number of thermalization updates
    metadata[&quot;N_measurements&quot;] = N_measurements  # Total number of measurements and measurement updates
    metadata[&quot;N_bins&quot;] = N_bins # Number of times bin-averaged measurements are written to file
    metadata[&quot;maxiter&quot;] = maxiter # Maximum number of conjugate gradient iterations
    metadata[&quot;tol&quot;] = tol # Tolerance used for conjugate gradient solves
    metadata[&quot;Nt&quot;] = Nt # Number of time-steps in HMC update
    metadata[&quot;Nrv&quot;] = Nrv # Number of random vectors used to estimate fermionic correlation functions
    metadata[&quot;seed&quot;] = seed  # Random seed used to initialize random number generator in simulation
    metadata[&quot;hmc_acceptance_rate&quot;] = 0.0 # HMC acceptance rate
    metadata[&quot;reflection_acceptance_rate&quot;] = 0.0 # Reflection update acceptance rate
    metadata[&quot;swap_acceptance_rate&quot;] = 0.0 # Swap update acceptance rate
    metadata[&quot;hmc_iters&quot;] = 0.0 # Avg number of CG iterations per solve in HMC update.
    metadata[&quot;reflection_iters&quot;] = 0.0 # Avg number of CG iterations per solve in reflection update.
    metadata[&quot;swap_iters&quot;] = 0.0 # Avg number of CG iterations per solve in swap update.
    metadata[&quot;measurement_iters&quot;] = 0.0 # Avg number of CG iterations per solve while making measurements.</code></pre><h2 id="Initialize-model"><a class="docs-heading-anchor" href="#Initialize-model">Initialize model</a><a id="Initialize-model-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Define lattice vectors.
    a1 = [+3/2, +√3/2]
    a2 = [+3/2, -√3/2]

    # Define basis vectors for two orbitals in the honeycomb unit cell.
    r1 = [0.0, 0.0] # Location of first orbital in unit cell.
    r2 = [1.0, 0.0] # Location of second orbital in unit cell.

    # Define the unit cell.
    unit_cell = lu.UnitCell(
        lattice_vecs = [a1, a2],
        basis_vecs   = [r1, r2]
    )

    # Define finite lattice with periodic boundary conditions.
    lattice = lu.Lattice(
        L = [L, L],
        periodic = [true, true]
    )

    # Initialize model geometry.
    model_geometry = ModelGeometry(unit_cell, lattice)

    # Define the first nearest-neighbor bond in a honeycomb lattice.
    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])

    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.
    bond_1_id = add_bond!(model_geometry, bond_1)

    # Define the second nearest-neighbor bond in a honeycomb lattice.
    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])

    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.
    bond_2_id = add_bond!(model_geometry, bond_2)

    # Define the third nearest-neighbor bond in a honeycomb lattice.
    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])

    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.
    bond_3_id = add_bond!(model_geometry, bond_3)

    # Set nearest-neighbor hopping amplitude to unity,
    # setting the energy scale in the model.
    t = 1.0

    # Define the honeycomb tight-binding model.
    tight_binding_model = TightBindingModel(
        model_geometry = model_geometry,
        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping
        t_mean         = [t, t, t], # defines corresponding hopping amplitude
        μ              = μ, # set chemical potential
        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy
    )

    # Initialize a null electron-phonon model.
    electron_phonon_model = ElectronPhononModel(
        model_geometry = model_geometry,
        tight_binding_model = tight_binding_model
    )

    # Define a dispersionless electron-phonon mode to live on each site in the lattice.
    phonon_1 = PhononMode(
        basis_vec = r1,
        Ω_mean = Ω
    )

    # Add the phonon mode definition to the electron-phonon model.
    phonon_1_id = add_phonon_mode!(
        electron_phonon_model = electron_phonon_model,
        phonon_mode = phonon_1
    )

    # Define a dispersionless electron-phonon mode to live on the second sublattice.
    phonon_2 = PhononMode(
        basis_vec = r2,
        Ω_mean = Ω
    )

    # Add the phonon mode definition to the electron-phonon model.
    phonon_2_id = add_phonon_mode!(
        electron_phonon_model = electron_phonon_model,
        phonon_mode = phonon_2
    )

    # Define first local Holstein coupling for first phonon mode.
    holstein_coupling_1 = HolsteinCoupling(
        model_geometry = model_geometry,
        phonon_id = phonon_1_id,
        orbital_id = 1,
        displacement = [0, 0],
        α_mean = α,
        ph_sym_form = true,
    )

    # Add the first local Holstein coupling definition to the model.
    holstein_coupling_1_id = add_holstein_coupling!(
        electron_phonon_model = electron_phonon_model,
        holstein_coupling = holstein_coupling_1,
        model_geometry = model_geometry
    )

    # Define second local Holstein coupling for second phonon mode.
    holstein_coupling_2 = HolsteinCoupling(
        model_geometry = model_geometry,
        phonon_id = phonon_2_id,
        orbital_id = 2,
        displacement = [0, 0],
        α_mean = α,
        ph_sym_form = true,
    )

    # Add the second local Holstein coupling definition to the model.
    holstein_coupling_2_id = add_holstein_coupling!(
        electron_phonon_model = electron_phonon_model,
        holstein_coupling = holstein_coupling_2,
        model_geometry = model_geometry
    )

    # Write model summary TOML file specifying Hamiltonian that will be simulated.
    model_summary(
        simulation_info = simulation_info,
        β = β, Δτ = Δτ,
        model_geometry = model_geometry,
        tight_binding_model = tight_binding_model,
        interactions = (electron_phonon_model,)
    )</code></pre><h2 id="Initialize-model-parameters"><a class="docs-heading-anchor" href="#Initialize-model-parameters">Initialize model parameters</a><a id="Initialize-model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model-parameters" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Initialize tight-binding parameters.
    tight_binding_parameters = TightBindingParameters(
        tight_binding_model = tight_binding_model,
        model_geometry = model_geometry,
        rng = rng
    )

    # Initialize electron-phonon parameters.
    electron_phonon_parameters = ElectronPhononParameters(
        β = β, Δτ = Δτ,
        electron_phonon_model = electron_phonon_model,
        tight_binding_parameters = tight_binding_parameters,
        model_geometry = model_geometry,
        rng = rng
    )</code></pre><h2 id="Initialize-measurements"><a class="docs-heading-anchor" href="#Initialize-measurements">Initialize measurements</a><a id="Initialize-measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-measurements" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)

    # Initialize the tight-binding model related measurements, like the hopping energy.
    initialize_measurements!(measurement_container, tight_binding_model)

    # Initialize the electron-phonon interaction related measurements.
    initialize_measurements!(measurement_container, electron_phonon_model)

    # Initialize the single-particle electron Green&#39;s function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;greens&quot;,
        time_displaced = true,
        pairs = [
            # Measure green&#39;s functions for all pairs or orbitals.
            (1, 1), (2, 2), (1, 2)
        ]
    )

    # Initialize the single-particle electron Green&#39;s function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;phonon_greens&quot;,
        time_displaced = true,
        pairs = [
            # Measure green&#39;s functions for all pairs of modes.
            (1, 1), (2, 2), (1, 2)
        ]
    )

    # Initialize density correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;density&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [
            (1, 1), (2, 2),
        ]
    )

    # Initialize the pair correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;pair&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [
            # Measure local s-wave pair susceptibility associated with
            # each orbital in the unit cell.
            (1, 1), (2, 2)
        ]
    )

    # Initialize the spin-z correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;spin_z&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [
            (1, 1), (2, 2)
        ]
    )

    # Initialize measurement of electron Green&#39;s function traced
    # over both orbitals in the unit cell.
    initialize_composite_correlation_measurement!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        name = &quot;tr_greens&quot;,
        correlation = &quot;greens&quot;,
        id_pairs = [(1,1), (2,2)],
        coefficients = [1.0, 1.0],
        time_displaced = true,
    )

    # Initialize CDW correlation measurement.
    initialize_composite_correlation_measurement!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        name = &quot;cdw&quot;,
        correlation = &quot;density&quot;,
        ids = [1, 2],
        coefficients = [1.0, -1.0],
        time_displaced = false,
        integrated = true
    )</code></pre><h2 id="Setup-QMC-simulation"><a class="docs-heading-anchor" href="#Setup-QMC-simulation">Setup QMC simulation</a><a id="Setup-QMC-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-QMC-simulation" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Allocate a single FermionPathIntegral for both spin-up and down electrons.
    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)

    # Initialize FermionPathIntegral type to account for electron-phonon interaction.
    initialize!(fermion_path_integral, electron_phonon_parameters)

    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count
    # used in conjugate gradient (CG) solves of linear systems involving this matrix.
    fermion_det_matrix = SymFermionDetMatrix(
        fermion_path_integral,
        maxiter = maxiter, tol = tol
    )

    # Initialize pseudofermion field calculator.
    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)

    # Initialize KPM preconditioner.
    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)

    # Initialize Green&#39;s function estimator for making measurements.
    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)</code></pre><h2 id="Setup-EFA-PFF-HMC-Updates"><a class="docs-heading-anchor" href="#Setup-EFA-PFF-HMC-Updates">Setup EFA-PFF-HMC Updates</a><a id="Setup-EFA-PFF-HMC-Updates-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-EFA-PFF-HMC-Updates" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.
    hmc_updater = EFAPFFHMCUpdater(
        electron_phonon_parameters = electron_phonon_parameters,
        Nt = Nt, Δt = π/(2*Nt)
    )</code></pre><h2 id="Thermalize-system"><a class="docs-heading-anchor" href="#Thermalize-system">Thermalize system</a><a id="Thermalize-system-1"></a><a class="docs-heading-anchor-permalink" href="#Thermalize-system" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Iterate over number of thermalization updates to perform.
    for update in 1:N_therm

        # Perform a reflection update.
        (accepted, iters) = reflection_update!(
            electron_phonon_parameters, pff_calculator,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            preconditioner = preconditioner,
            rng = rng, tol = tol, maxiter = maxiter
        )

        # Record whether the reflection update was accepted or rejected.
        metadata[&quot;reflection_acceptance_rate&quot;] += accepted

        # Record the number of CG iterations performed for the reflection update.
        metadata[&quot;reflection_iters&quot;] += iters

        # Perform a swap update.
        (accepted, iters) = swap_update!(
            electron_phonon_parameters, pff_calculator,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            preconditioner = preconditioner,
            rng = rng, tol = tol, maxiter = maxiter
        )

        # Record whether the reflection update was accepted or rejected.
        metadata[&quot;swap_acceptance_rate&quot;] += accepted

        # Record the number of CG iterations performed for the reflection update.
        metadata[&quot;swap_iters&quot;] += iters

        # Perform an HMC update.
        (accepted, iters) = hmc_update!(
            electron_phonon_parameters, hmc_updater,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            pff_calculator = pff_calculator,
            preconditioner = preconditioner,
            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,
            rng = rng,
        )

        # Record the average number of iterations per CG solve for hmc update.
        metadata[&quot;hmc_acceptance_rate&quot;] += accepted

        # Record the number of CG iterations performed for the reflection update.
        metadata[&quot;hmc_iters&quot;] += iters
    end</code></pre><h2 id="Make-measurements"><a class="docs-heading-anchor" href="#Make-measurements">Make measurements</a><a id="Make-measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Make-measurements" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Calculate the bin size.
    bin_size = N_measurements ÷ N_bins

    # Iterate over bins.
    for measurement in 1:N_measurements

        # Perform a reflection update.
        (accepted, iters) = reflection_update!(
            electron_phonon_parameters, pff_calculator,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            preconditioner = preconditioner,
            rng = rng, tol = tol, maxiter = maxiter
        )

        # Record whether the reflection update was accepted or rejected.
        metadata[&quot;reflection_acceptance_rate&quot;] += accepted

        # Record the number of CG iterations performed for the reflection update.
        metadata[&quot;reflection_iters&quot;] += iters

        # Perform a swap update.
        (accepted, iters) = swap_update!(
            electron_phonon_parameters, pff_calculator,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            preconditioner = preconditioner,
            rng = rng, tol = tol, maxiter = maxiter
        )

        # Record whether the reflection update was accepted or rejected.
        metadata[&quot;swap_acceptance_rate&quot;] += accepted

        # Record the number of CG iterations performed for the reflection update.
        metadata[&quot;swap_iters&quot;] += iters

        # Perform an HMC update.
        (accepted, iters) = hmc_update!(
            electron_phonon_parameters, hmc_updater,
            fermion_path_integral = fermion_path_integral,
            fermion_det_matrix = fermion_det_matrix,
            pff_calculator = pff_calculator,
            preconditioner = preconditioner,
            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,
            rng = rng,
        )

        # Record whether the reflection update was accepted or rejected.
        metadata[&quot;hmc_acceptance_rate&quot;] += accepted

        # Record the average number of iterations per CG solve for hmc update.
        metadata[&quot;hmc_iters&quot;] += iters

        # Make measurements.
        iters = make_measurements!(
            measurement_container, fermion_det_matrix, greens_estimator,
            model_geometry = model_geometry,
            fermion_path_integral = fermion_path_integral,
            tight_binding_parameters = tight_binding_parameters,
            electron_phonon_parameters = electron_phonon_parameters,
            preconditioner = preconditioner,
            tol = tol, maxiter = maxiter,
            rng = rng
        )

        # Record the average number of iterations per CG solve for measurements.
        metadata[&quot;measurement_iters&quot;] += iters

        # Write the bin-averaged measurements to file.
        write_measurements!(
            measurement_container = measurement_container,
            simulation_info = simulation_info,
            model_geometry = model_geometry,
            measurement = measurement,
            bin_size = bin_size,
            Δτ = Δτ
        )
    end</code></pre><h2 id="Merge-binned-data"><a class="docs-heading-anchor" href="#Merge-binned-data">Merge binned data</a><a id="Merge-binned-data-1"></a><a class="docs-heading-anchor-permalink" href="#Merge-binned-data" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Merge binned data into a single HDF5 file.
    merge_bins(simulation_info)</code></pre><h2 id="Record-simulation-metadata"><a class="docs-heading-anchor" href="#Record-simulation-metadata">Record simulation metadata</a><a id="Record-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Record-simulation-metadata" title="Permalink"></a></h2><p>No changes need to made to this section of the code from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial.</p><pre><code class="language-julia hljs">    # Calculate acceptance rates.
    metadata[&quot;hmc_acceptance_rate&quot;] /= (N_measurements + N_therm)
    metadata[&quot;reflection_acceptance_rate&quot;] /= (N_measurements + N_therm)
    metadata[&quot;swap_acceptance_rate&quot;] /= (N_measurements + N_therm)

    # Calculate average number of CG iterations.
    metadata[&quot;hmc_iters&quot;] /= (N_measurements + N_therm)
    metadata[&quot;reflection_iters&quot;] /= (N_measurements + N_therm)
    metadata[&quot;swap_iters&quot;] /= (N_measurements + N_therm)
    metadata[&quot;measurement_iters&quot;] /= N_measurements

    # Write simulation metadata to simulation_info.toml file.
    save_simulation_info(simulation_info, metadata)</code></pre><h2 id="Post-process-results"><a class="docs-heading-anchor" href="#Post-process-results">Post-process results</a><a id="Post-process-results-1"></a><a class="docs-heading-anchor-permalink" href="#Post-process-results" title="Permalink"></a></h2><p>The main change we need to make from the previous <a href="../holstein_honeycomb/#1a)-Honeycomb-Holstein-Model">1a) Honeycomb Holstein Model</a> tutorial is to call the <a href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/#SmoQyDQMC.process_measurements"><code>SmoQyDQMC.process_measurements</code></a> and <a href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/#SmoQyDQMC.compute_composite_correlation_ratio"><code>SmoQyDQMC.compute_composite_correlation_ratio</code></a> functions such that the first argument is the <code>comm</code> object, thereby ensuring a parallelized version of each method is called.</p><pre><code class="language-julia hljs">    # Process the simulation results, calculating final error bars for all measurements.
    # writing final statistics to CSV files.
    process_measurements(
        comm,
        datafolder = simulation_info.datafolder,
        n_bins = N_bins,
        export_to_csv = true,
        scientific_notation = false,
        decimals = 7,
        delimiter = &quot; &quot;
    )

    # Calculate CDW correlation ratio.
    Rcdw, ΔRcdw = compute_composite_correlation_ratio(
        datafolder = simulation_info.datafolder,
        name = &quot;cdw&quot;,
        type = &quot;equal-time&quot;,
        q_point = (0, 0),
        q_neighbors = [
            (1,0),   (0,1),   (1,1),
            (L-1,0), (0,L-1), (L-1,L-1)
        ]
    )

    # Record the AFM correlation ratio mean and standard deviation.
    metadata[&quot;Rcdw_mean_real&quot;] = real(Rcdw)
    metadata[&quot;Rcdw_mean_imag&quot;] = imag(Rcdw)
    metadata[&quot;Rcdw_std&quot;]       = ΔRcdw

    # Write simulation summary TOML file.
    save_simulation_info(simulation_info, metadata)

    return nothing
end # end of run_simulation function</code></pre><h2 id="Execute-script"><a class="docs-heading-anchor" href="#Execute-script">Execute script</a><a id="Execute-script-1"></a><a class="docs-heading-anchor-permalink" href="#Execute-script" title="Permalink"></a></h2><p>Here we first need to initialize MPI using the <a href="https://juliaparallel.org/MPI.jl/stable/reference/environment/#MPI.Init"><code>MPI.Init</code></a> command. Then, we need to make sure to pass the <code>comm = MPI.COMM_WORLD</code> to the <code>run_simulation</code> function. At the very end of simulation it is good practice to run the <code>MPI.Finalize()</code> function even though it is typically not strictly required.</p><pre><code class="language-julia hljs"># Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Initialize MPI
    MPI.Init()

    # Initialize the MPI communicator.
    comm = MPI.COMM_WORLD

    # Run the simulation.
    run_simulation(
        comm;
        sID = parse(Int, ARGS[1]), # Simulation ID.
        Ω = parse(Float64, ARGS[2]), # Phonon energy.
        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.
        μ = parse(Float64, ARGS[4]), # Chemical potential.
        L = parse(Int, ARGS[5]), # System size.
        β = parse(Float64, ARGS[6]), # Inverse temperature.
        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.
        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.
        N_bins = parse(Int, ARGS[9]) # Number of times bin-averaged measurements are written to file.
    )

    # Finalize MPI.
    MPI.Finalize()
end</code></pre><p>Here is an example of what the command to run this script might look like:</p><pre><code class="language-bash hljs">mpiexecjl -n 16 julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100</code></pre><p>This will 16 MPI processes, each running and independent simulation using a different random seed the the final results arrived at by averaging over all 16 walkers. Here <code>mpiexecjl</code> is the MPI executable that can be easily install using the directions found <a href="https://juliaparallel.org/MPI.jl/stable/usage/#Julia-wrapper-for-mpiexec">here</a> in the <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a> documentation. However, you can substitute a different MPI executable here if one is already configured on your system.</p><p>Also, when submitting jobs via <a href="https://slurm.schedmd.com/documentation.html">SLURM</a> on a High-Performance Computing (HPC) cluster, if a default MPI executable is already configured on the system, as is frequently the case, then the script can likely be run inside the <code>*.sh</code> job file using the <a href="https://slurm.schedmd.com/srun.html"><code>srun</code></a> command:</p><pre><code class="language-bash hljs">srun julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100</code></pre><p>The <code>srun</code> command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../holstein_honeycomb/">« 1a) Honeycomb Holstein Model</a><a class="docs-footer-nextpage" href="../holstein_honeycomb_checkpoint/">1c) Honeycomb Holstein Model with Checkpointing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Monday 23 February 2026 21:12">Monday 23 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
