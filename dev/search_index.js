var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Fermion-Determinant-Matrix","page":"API","title":"Fermion Determinant Matrix","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionDetMatrix\nSymFermionDetMatrix\nAsymFermionDetMatrix","category":"page"},{"location":"api/#SmoQyElPhQMC.FermionDetMatrix","page":"API","title":"SmoQyElPhQMC.FermionDetMatrix","text":"FermionDetMatrix{T<:Number, E<:AbstractFloat}\n\nA abstract type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere B_l are propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.SymFermionDetMatrix","page":"API","title":"SmoQyElPhQMC.SymFermionDetMatrix","text":"SymFermionDetMatrix{T<:Number, E<:AbstractFloat} <: FermionDetMatrix{T,E}\n\nA type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere\n\nB_l = left e^-Deltatau K_l2 right^dagger e^-Deltatau V_l e^-Deltatau K_l2\n\nare Hermitian (symmetric if real) propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice. Here the matrix e^-Deltatau K_l2 is  approximated using the non-hermitian checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.SymFermionDetMatrix-Union{Tuple{FermionPathIntegral{T, E}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.SymFermionDetMatrix","text":"SymFermionDetMatrix(\n    fermion_path_integral::FermionPathIntegral{T, E};\n    maxiter::Int = (fermion_path_integral.N * fermion_path_integral.Lτ),\n    tol::E = 1e-6\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the SymFermionDetMatrix type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.AsymFermionDetMatrix","page":"API","title":"SmoQyElPhQMC.AsymFermionDetMatrix","text":"AsymFermionDetMatrix{T<:Number, E<:AbstractFloat} <: FermionDetMatrix{T, E}\n\nA type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nare Hermitian (symmetric if real) propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice. Note that e^-Deltatau K_l is represented using the non-hermitian checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.AsymFermionDetMatrix-Union{Tuple{FermionPathIntegral{T, E}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.AsymFermionDetMatrix","text":"AsymFermionDetMatrix(\n    fermion_path_integral::FermionPathIntegral{T, E};\n    maxiter::Int = (fermion_path_integral.N * fermion_path_integral.Lτ),\n    tol::E = 1e-6\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the AsymFermionDetMatrix type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Preconditioners","page":"API","title":"Preconditioners","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"KPMPreconditioner\nSymKPMPreconditioner\nAsymKPMPreconditioner","category":"page"},{"location":"api/#SmoQyElPhQMC.KPMPreconditioner","page":"API","title":"SmoQyElPhQMC.KPMPreconditioner","text":"abstract type KPMPreconditioner{T<:Number, E<:AbstractFloat} end\n\nAbstract type representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix. Here, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.KPMPreconditioner-Union{Tuple{FermionDetMatrix{T}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.KPMPreconditioner","text":"KPMPreconditioner(\n    fermion_det_matrix::FermionDetMatrix{T};\n    # Keyword Arguments\n    rng::AbstractRNG = Random.default_rng(),\n    rbuf::E = 0.10,\n    n::Int = 20,\n    a1::E = 1.0,\n    a2::E = 1.0\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize and return an instance of either the SymKPMPreconditioner or AsymKPMPreconditioner type.\n\nArguments\n\nfermion_det_matrix::FermionDetMatrix{T}: Fermion determinant matrix.\n\nKeyword Arguments\n\nrng::AbstractRNG = Random.default_rng(): Random number generator.\nrbuf::E = 0.10: Relative buffer applied to eigevalue bounds of barB calculated by Lanczos.\nn::Int = 20: Number of lanczos iterations used to approximate eigenvalue bounds.\na1::E = 1.0: Controls maximum order of kpm expansion.\na2::E = 1.0: Controls minimum order of kpm expansion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.SymKPMPreconditioner","page":"API","title":"SmoQyElPhQMC.SymKPMPreconditioner","text":"mutable struct SymKPMPreconditioner{T, E, Tfft, Tifft} <: KPMPreconditioner{T, E}\n\nType representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix defined using the symmetric propagator definition\n\nB_l = e^-Deltatau K_l2 e^-Deltatau V_l e^-Deltatau K_l2\n\nHere, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.AsymKPMPreconditioner","page":"API","title":"SmoQyElPhQMC.AsymKPMPreconditioner","text":"mutable struct AsymKPMPreconditioner{T, E, Tfft, Tifft} <: KPMPreconditioner{T, E}\n\nType representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix defined using the asymmetric propagator definition\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nHere, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#Monte-Carlo-Update-Methods","page":"API","title":"Monte Carlo Update Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PFFCalculator\nEFAPFFHMCUpdater\nhmc_update!\nreflection_update!\nswap_update!\nradial_update!","category":"page"},{"location":"api/#SmoQyElPhQMC.PFFCalculator","page":"API","title":"SmoQyElPhQMC.PFFCalculator","text":"PFFCalculator{T<:AbstractFloat}\n\nThe PFFCalaculatr type, short for pseudo-fermion field calcutor, is for facilitating the sampling the pseudo-fermion fields Phi, evaluate the fermionic action S_f and calculating it's partial derivatives partial S_fpartial x_taui with respect to each phonon field x_taui\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.PFFCalculator-Union{Tuple{E}, Tuple{T}, Tuple{ElectronPhononParameters{T, E}, FermionDetMatrix{T, E}}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.PFFCalculator","text":"PFFCalculator(\n    # Arguments\n    electron_phonon_parameters::ElectronPhononParameters{T},\n    fermion_det_matrix::FermionDetMatrix{T};\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the PFFCalculator type used for calculating the pseudo-fermion fields Phi. The tol and maxiter keywords specify the tolerance and maximum number of iterations used when performing conjugate gradient solves to evaluate the fermionic action given the current fields Phi.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.EFAPFFHMCUpdater","page":"API","title":"SmoQyElPhQMC.EFAPFFHMCUpdater","text":"struct EFAPFFHMCUpdater{T<:AbstractFloat, PFFT, PIFFT}\n\nType to define how to perform an Hybrid/Hamiltonian Monte Carlo (HMC) updates of the phonon fields using a fermionic action formulated by introducing a complex pseudofermion field (PFF) \\Phi. Exact Fourier Acceleration (EFA) is also used to more efficiently sample the phonon fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.EFAPFFHMCUpdater-Tuple{}","page":"API","title":"SmoQyElPhQMC.EFAPFFHMCUpdater","text":"EFAPFFHMCUpdater(;\n    # Keyword Arguments\n    electron_phonon_parameters::ElectronPhononParameters{T},\n    Nt::Int,\n    Δt::E,\n    η::E = 0.0,\n    δ::E = 0.05\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of EFAPFFHMCUpdater type, defining an EFA-PFF-HMC update.\n\nKeyword Arguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T}: Parameters defining the electron-phonon model.\nNt::Int: Number of HMC time-steps.\nΔt::E: Time-step for HMC update.\nη::E = 0.0: Regularization parameter for EFA.\nδ::E = 0.05: Fractional noise to add to the time-step Δt.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAPFFHMCUpdater{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    pff_calculator::PFFCalculator{E},\n    rng::AbstractRNG,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ,\n    tol_action::E = fermion_det_matrix.cg.tol,\n    tol_force::E = sqrt(fermion_det_matrix.cg.tol),\n    max_iter::Int = fermion_det_matrix.cg.maxiter,\n    preconditioner = I\n) where {T, E}\n\nPerform an EFA-PFF-HMC update to the phonon fields. Acronym EFA-PFF-HMC stands for pseudofermion field (PPF) Hamiltonian/hyrbid Monte Carlo (HMC) update with exact Fourier acceleration (EFA) used to reduce autocorrelation times.\n\nKeyword Arguments with Default Values\n\nrecenter!::Function = identity: Function to recenter the phonon fields after the update.\nNt::Int = hmc_updater.Nt: Number of HMC time-steps.\nΔt::E = hmc_updater.Δt: Time-step for HMC update.\nδ::E = hmc_updater.δ: Fractional noise to add to the time-step Δt.\ntol_action::E = fermion_det_matrix.cg.tol: Tolerance used in CG solve to evaluate fermionic action.\ntol_force::E = sqrt(fermion_det_matrix.cg.tol): Tolerance used in CG solve to evaluate derivative of fermionic action.\nmax_iter::Int = fermion_det_matrix.cg.maxiter: Maximum number of iterations for CG solve.\npreconditioner = I: Preconditioner used in CG solves.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.reflection_update!","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_types = nothing\n) where {T<:Number, E<:AbstractFloat}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x The argument phonon_types specifies the phonon ID's that are included for randomly sampling a phonon mode in the lattice to perform a swap update on. If phonon_types = nothing, then all types of phonon modes are included. This function returns a tuple containing (accepted, iters), where accepted is a boolean indicating whether the update was accepted or rejected, and iters is the number of CG iterations performed to calculate the fermionic action.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.swap_update!","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_type_pairs = nothing\n) where {T<:Number, E<:AbstractFloat}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. The argument phonon_type_pairs specifies pairs phonon IDs that are used to randomly samples a pairs of phonon modes. If phonon_type_pairs = nothing, then all possible pairs of phonon types/IDs are allowed. This function returns a tuple containing (accepted, iters), where accepted is a boolean indicating whether the update was accepted or rejected, and iters is the number of CG iterations performed to calculate the fermionic action.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.radial_update!","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_id::Union{Nothing,Int} = nothing,\n    σ::E = 1.0\n) where {T<:Number, E<:AbstractFloat}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"GreensEstimator\nmake_measurements!","category":"page"},{"location":"api/#SmoQyElPhQMC.GreensEstimator","page":"API","title":"SmoQyElPhQMC.GreensEstimator","text":"GreensEstimator{T<:AbstractFloat, Dp1, Dp3, Tfft<:AbstractFFTs.Plan, Tifft<:AbstractFFTs.Plan}\n\nThis type is used to compute stochastic estimates of the Green's function and other correlation functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.GreensEstimator-Union{Tuple{E}, Tuple{T}, Tuple{D}, Tuple{FermionDetMatrix{T, E}, ModelGeometry{D, E}}} where {D, T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.GreensEstimator","text":"GreensEstimator(\n    # Arguments\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    model_geometry::ModelGeometry{D,E};\n    # Keyword Arguments\n    Nrv::Int = 10,\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    maxiter::Int = fermion_det_matrix.cgs.maxiter,\n    tol::E = fermion_det_matrix.cgs.tol\n) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the type GreensEstimator.\n\nArguments\n\nfermion_det_matrix::FermionDetMatrix{T,E}: Fermion determinant matrix.\nmodel_geometry::ModelGeometry{D,E}: Defines model geometry.\n\nKeyword Arguments\n\nNrv::Int = 10: Number of random vectors used to approximate Green's function.\npreconditioner = I: Preconditioner used to solve linear system.\nrng = Random.default_rng(): Random number generator.\nmaxiter::Int = fermion_det_matrix.cgs.maxiter: Maximum number of iterations for linear solver.\ntol::E = fermion_det_matrix.cgs.tol: Tolerance for linear solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(\n    measurement_container::NamedTuple,\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    greens_estimator::GreensEstimator{E,D};\n    # Keyword Arguments Start Here\n    model_geometry::ModelGeometry{D,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter\n) where {T<:Number, E<:AbstractFloat, D}\n\nMake all measurements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chemical-Potential-Tuning","page":"API","title":"Chemical Potential Tuning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!","category":"page"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    greens_estimator::GreensEstimator{E,D};\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    update_greens_estimator::Bool = true\n) where {D, T<:Number, E<:AbstractFloat}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. If update_greens_estimator = true, then greens_estimator is initialized to reflect the current state of the fermion_det_matrix.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/holstein_honeycomb/#1a)-Honeycomb-Holstein-Model","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this example we reimplement the SmoQyDQMC tuturial on simulating the Holstein model on a Honeycomb lattice using SmoQyElPhQMC. The Holstein Hamiltonian is given by","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"beginalign*\nhatH =  -t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n- mu sum_isigma hatn_sigmai \n + frac12 M Omega^2 sum_i hatX_i^2 + sum_i frac12M hatP_i^2\n+ alpha sum_i hatX_i (hatn_uparrowi + hatn_downarrowi - 1)\nendalign*","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. Here mu is the chemical potential and  t is the nearest-neighbor hopping amplitude, with the sum over langle ij rangle denoting a sum over all nearest-neighbor pairs of sites. A local dispersionless phonon mode is then placed on each site in the lattice, with hatX_i and hatP_i the corresponding phonon position and momentum operator on site i in the lattice. The phonon mass and energy are denoted M and Omega respectively. Lastly, the phonon displacement hatX_i couples to the total local density hatn_uparrowi + hatn_downarrowi with the parameter alpha controlling the strength of this coupling.","category":"page"},{"location":"tutorials/holstein_honeycomb/#Import-packages","page":"1a) Honeycomb Holstein Model","title":"Import packages","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"First, we begin by importing the necessary packages. The SmoQyElPhQMC package is built as an extension pacakge on top of SmoQyDQMC, enabling the simulution of strictly spin-symmetric electron-phonon models. Therefore, in addition to importing SmoQyElPhQMC, we also need to import SmoQyDQMC. The SmoQyDQMC package also then rexports the LatticeUtilities package, which we will use to define the lattice geometry for our model.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Lastly, we use the Standard Library packages Random and Printf for random number generation and C-style string formatting, respectively.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"using SmoQyElPhQMC\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf","category":"page"},{"location":"tutorials/holstein_honeycomb/#Specify-simulation-parameters","page":"1a) Honeycomb Holstein Model","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations. The specific meaning of each argument will be discussed in later sections of the tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 100, # Numer of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 1000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation","page":"1a) Honeycomb Holstein Model","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this first part of the script we name and initialize our simulation, creating the data folder our simulation results will be written to. This is done by initializing an instances of the SmoQyDQMC.SimulationInfo type, as well as an additional_info dictionary where we will store useful metadata about the simulation. Finally, the integer seed is used to initialize the random number generator rng that will be used to generate random numbers throughout the rest of the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Next we record relevant simulation parameters to the additional_info dictionary. Think of the additional_info dictionary as a place to record any additional information during the simulation that will not otherwise be automatically recorded and written to file.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation-metadata","page":"1a) Honeycomb Holstein Model","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize additiona_info dictionary\n    additional_info = Dict()\n\n    # Record simulation parameters.\n    additional_info[\"N_therm\"]   = N_therm    # Number of thermalization updates\n    additional_info[\"N_updates\"] = N_updates  # Total number of measurements and measurement updates\n    additional_info[\"N_bins\"]    = N_bins     # Number of times bin-averaged measurements are written to file\n    additional_info[\"maxiter\"]   = maxiter    # Maximum number of conjugate gradient iterations\n    additional_info[\"tol\"]       = tol        # Tolerance used for conjugate gradient solves\n    additional_info[\"Nt\"]        = Nt         # Number of time-steps in HMC update\n    additional_info[\"Nrv\"]       = Nrv        # Number of random vectors used to estimate fermionic correlation functions\n    additional_info[\"seed\"]      = seed       # Random seed used to initialize random number generator in simulation","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Here we also update variables to keep track of the acceptance rates for the various types of Monte Carlo updates that will be performed during the simulation. This will be discussed in more detail in later sections of the tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    metadata[\"hmc_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n    metadata[\"swap_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Initialize variables to record the average number of CG iterations for each type of update and measurements.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    additional_info[\"hmc_iters\"] = 0.0\n    additional_info[\"reflection_iters\"] = 0.0\n    additional_info[\"swap_iters\"] = 0.0\n    additional_info[\"measurement_iters\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-model","page":"1a) Honeycomb Holstein Model","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters the phonon energy Omega (Ω), electron-phonon coupling alpha (α), chemical potential mu (μ), and lattice size L (L). The neasrest-neighbor hopping amplitude and phonon mass are normalized to unity, t = M = 1.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"First we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the LatticeUtilities.UnitCell and LatticeUtilities.Lattice types, respectively. Lastly, we define various instances of the LatticeUtilities.Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the SmoQyDQMC.ModelGeometry type.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Next we specify the Honeycomb tight-binding term in our Hamiltonian with the SmoQyDQMC.TightBindingModel type.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Set neartest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Now we need to initialize the electron-phonon part of the Hamiltonian with the ElectronPhononModel type.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Then we need to define and add two types phonon modes to the model, one for each orbital in the Honeycomb unit cell, using the SmoQyDQMC.PhononMode type and SmoQyDQMC.add_phonon_mode! function.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Now we need to define and add a local Holstein couplings to our model for each of the two phonon modes in each unit cell using the SmoQyDQMC.HolsteinCoupling type and SmoQyDQMC.add_holstein_coupling! function.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_1_id,\n        # Couple the first phonon mode to first orbital in the unit cell.\n        bond = lu.Bond(orbitals = (1,1), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_2_id,\n        # Couple the second phonon mode to second orbital in the unit cell.\n        bond = lu.Bond(orbitals = (2,2), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Lastly, the SmoQyDQMC.model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-model-parameters","page":"1a) Honeycomb Holstein Model","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the SmoQyDQMC.TightBindingModel and SmoQyDQMC.ElectronPhononModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC and SmoQyElPhQMC supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize seperate parameter values for each unit cell in the lattice. For instance, we need to initialize a seperate number to represent the on-site energy for each orbital in our finite lattice.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-meuasurements","page":"1a) Honeycomb Holstein Model","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"It is also useful to initialize more specialized composite correlation function measurements. Specifically, to detect the formation of charge-density wave order where the electrons preferentially localize on one of the two sub-lattices of the honeycomb lattice, it is useful to measure the correlation function","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"C_textcdw(mathbfrtau) = frac1L^2sum_mathbfi langle hatPhi^dagger_mathbfi+mathbfr(tau) hatPhi^phantomdagger_mathbfi(0) rangle","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"where","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"hatPhi_mathbfi(tau) = hatn_mathbfiA(tau) - hatn_mathbfiB(tau)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"and hatn_mathbfigamma = (hatn_uparrowmathbfio + hatn_downarrowmathbfio) is the total electron number operator for orbital gamma in AB in unit cell mathbfi. It is then also useful to calculate the corresponding structure factor S_textcdw(mathbfqtau) and susceptibility chi_textcdw(mathbfq) This can all be easily calculated using the SmoQyDQMC.initialize_composite_correlation_measurement! function, as shown below.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        time_displaced = false,\n        integrated = true\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The SmoQyDQMC.initialize_measurement_directories can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. Again, for more information refer to the Simulation Output Overview page.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(simulation_info, measurement_container)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Setup-QMC-Simulation","page":"1a) Honeycomb Holstein Model","title":"Setup QMC Simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"This section of the code sets up the QMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"This section of code is perhaps the most opaque and difficult to understand, and will be discussed in more detail once written. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a QMC simulation for a different Hamiltonian.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"At the start of this section, an instance of the FermionPathIntegral type was allocated and then initialized. Recall that after discretizing the imaginary-time axis and applying the Suszuki-Trotter approximation, the resulting Hamiltonian is quadratic in fermion creation and annihilation operators, but fluctuates in imaginary-time as a result of the phonon fields. Therefore, this Hamiltonian may be expressed as","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"hatH_l = sum_sigma hatmathbfc_sigma^dagger left H_sigmal right hatmathbfc_sigma\n= sum_sigma hatmathbfc_sigma^dagger left K_sigmal + V_sigmal right hatmathbfc_sigma","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"at imaginary-time tau = Deltatau cdot l, where hatmathbfc_sigma  (hatmathbfc_sigma^dagger) is a column (row) vector of spin-sigma electron annihilation (creation) operators for each orbital in the lattice. Here H_sigmal is the spin-sigma Hamiltonian matrix for imaginary-time tau, which can be expressed as the sum of the electron kinetic and potential energy matrices K_sigmal and V_sigmal, respectively.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The purpose of the SmoQyDQMC.FermionPathIntegral type is to contain the minimal information required to reconstruct each K_sigmal and V_sigmal matrices. Here we only need to allocate a single instance of the SmoQyDQMC.FermionPathIntegral type as we assume spin symmetry. The SmoQyDQMC.FermionPathIntegral instance is first allocated and initialized to reflect just the non-interacting component of the Hamiltonian. Then the subsequent SmoQyDQMC.initialize! call modifies the SmoQyDQMC.FermionPathIntegral to reflect the contribution from the initial phonon field configuration.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Next we initialize an instance of the AsymFermionDetMatrix type of represent the Fermion determinant matrix, where is an inherited type from the abstracy FermionDetMatrix type. We could have used an instance of the SymFermionDetMatrix here instead if we wanted to.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = AsymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Now we can initialize an instance of the PFFCalculator type, which is used to sample and store the complex pseudofermion fields Phi and evaluate the fermionic action","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"S_F(xPhi) = Phi^dagger leftLambda^dagger(x) M^dagger(x) M^phantomdagger(x) Lambda^phantomdagger(x)right^-1 Phi^phantomdagger","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"where M(x) is the fermion determinant matrix and Lambda(x) is a unitary transformation specially chosen to improve sampling. These auxialary fields result from replacing the fermion determinants by a complex multivariate Gaussian integral","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"det M(x)^2 propto int dPhi e^-S_F(xPhi)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Evaluating the fermionic action S(Fx), and its partial derivatives with respect to the phonon fields, requires solving linear system of the form","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"left M^dagger(x) M^phantomdagger(x) right v = b","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"which is done using the conjugate gradient (CG) method. This is the most expensive operation in the QMC simulation. We use the KPMPreconditioner type to accelerate the convergence of the CG calculations, thereby accelerating the simulations.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize KPM preconditioner.\n    kpm_preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Finally, we initialize an instance of the GreensEstimator type, which is for estimating fermionic correlation functions when making measurements.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)","category":"page"},{"location":"tutorials/holstein_honeycomb/#holstein_square_efa-hmc_updates","page":"1a) Honeycomb Holstein Model","title":"Setup EFA-HMC Updates","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Before we begin the simulation, we also want to initialize an instance of the EFAPFFHMCUpdater type, which will be used to perform hybrid Monte Carlo (HMC) udpates to the phonon fields that use exact fourier acceleration (EFA) to further reduce autocorrelation times.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The two main parameters that need to be specified are the time-step size Delta t and number of time-steps N_t performed in the HMC update, with the corresponding integrated trajectory time then equalling T_t = N_t cdot Delta t Note that the computational cost of an HMC update is linearly proportional to N_t while the acceptance rate is inversely proportional to Delta t","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Previous studies have shown that a good place to start with the integrated trajectory time T_t is a quarter the period of the bare phonon mode, T_t approx frac14 left( frac2piOmega right) = pi(2Omega) It is also important to keep the acceptance rate for the HMC updates above sim 90 to help prevent numerical instabilities from occuring.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Based on user experience, a good (conservative) starting place is to set the number of time-step to N_t approx 100 and then set the time-step size to Delta t approx pi(2Omega N_t) effectively setting the integrated trajectory time to T_t = pi(2Omega) Then, if the acceptance rate is too low you increase N_t which results in a reduction of Delta t Conversely, if the acceptance rate is very high (gtrsim 99  ) it can be useful to decrease N_t, thereby increasing Delta t as this will reduce the computational cost of performing an EFA-HMC update.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The following code initializes the EFA-HMC updater, and sets the time-step size and number of time-steps","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Integrated trajectory time; one quarter the period of the bare phonon mode.\n    Tt = π/(2Ω)\n\n    # Fermionic time-step used in HMC update.\n    Δt = Tt/Nt","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = Δt,\n        η = 0.0, # Regularization parameter for exact fourier acceleration (EFA)\n        δ = 0.05 # Fractional max amplitude of noise added to time-step Δt before each HMC update.\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Thermalize-system","page":"1a) Honeycomb Holstein Model","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. In addition to EFA-HMC updates that will be performed using the EFAPFFHMCUpdater type initialized above and the hmc_update! function below, we will also perform reflection and swap updates using the reflection_update! and swap_update! functions respectively.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = kpm_preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        additional_info[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = kpm_preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        additional_info[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = kpm_preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        additional_info[\"hmc_iters\"] += iters\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb/#Make-measurements","page":"1a) Honeycomb Holstein Model","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this next section of code we continue to sample the phonon fields as above, but will also begin making measurements as well. For more discussion on the overall structure of this part of the code, refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over bins.\n    for update in 1:N_updates\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = kpm_preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        additional_info[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = kpm_preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        additional_info[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = kpm_preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        additional_info[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = kpm_preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        additional_info[\"measurement_iters\"] += iters\n\n        # Check if bin averaged measurements need to be written to file.\n        if update % bin_size == 0\n\n            # Write the bin-averaged measurements to file.\n            write_measurements!(\n                measurement_container = measurement_container,\n                simulation_info = simulation_info,\n                model_geometry = model_geometry,\n                bin = update ÷ bin_size,\n                bin_size = bin_size,\n                Δτ = Δτ\n            )\n        end\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb/#Record-simulation-metadata","page":"1a) Honeycomb Holstein Model","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the various types of udpates we performed, as well as write the simulation metadata to file, including the contents of the additional_info dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_therm)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_therm)\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_therm)\n\n    # Calculate average number of CG iterations.\n    additional_info[\"hmc_iters\"] /= (N_updates + N_therm)\n    additional_info[\"reflection_iters\"] /= (N_updates + N_therm)\n    additional_info[\"swap_iters\"] /= (N_updates + N_therm)\n    additional_info[\"measurement_iters\"] /= N_updates\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, additional_info)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Process-results","page":"1a) Honeycomb Holstein Model","title":"Process results","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this final section of code we process the binned data, calculating final estimates for the mean and error of all measured observables. The final statistics are written to CSV files using the function process_measurements function. For more information refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins, time_displaced = false)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(folder = simulation_info.datafolder)\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/holstein_honeycomb/#Execute-script","page":"1a) Honeycomb Holstein Model","title":"Execute script","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_simulation(\n        sID       = parse(Int,     ARGS[1]),\n        Ω         = parse(Float64, ARGS[2]),\n        α         = parse(Float64, ARGS[3]),\n        μ         = parse(Float64, ARGS[4]),\n        L         = parse(Int,     ARGS[5]),\n        β         = parse(Float64, ARGS[6]),\n        N_therm   = parse(Int,     ARGS[7]),\n        N_updates = parse(Int,     ARGS[8]),\n        N_bins    = parse(Int,     ARGS[9]),\n    )\nend","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"For instance, the command","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"> julia holstein_honeycomb.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"runs a DQMC simulation of a Holstein model on a 3 times 3 unit cell (N = 2 \\times 3^2 = 18 site) honeycomb lattice at half-filling (mu = 0) and inverse temperature beta = 40. The phonon energy is set to Omega = 10 and the electron-phonon coupling is set to alpha = 15 In the DQMC simulation, 5,000 EFA-HMC, reflection and swap updates are performed to thermalize the system. Then an additional 10,000 such udpates are performed, after each of set of which measurements are made. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 10,000/100 = 100 sequential measurements.","category":"page"},{"location":"#SmoQyElPhQMC","page":"Home","title":"SmoQyElPhQMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyElPhQMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SmoQyElPhQMC package is part of SmoQySuite, and is a package that extends the functionality of the SmoQyDQMC package. Specifically, it allows for near linear scaling quantum Monte Carlo simulations of spin-symmetric electron-phonon models, absent any Hubbard interactions. This package implements a modified version of the algorithm introduced in this article:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{PhysRevE.105.065302,\n  title = {Fast and scalable quantum Monte Carlo simulations of electron-phonon models},\n  author = {Cohen-Stead, Benjamin and Bradley, Owen and Miles, Cole and Batrouni, George and Scalettar, Richard and Barros, Kipton},\n  journal = {Phys. Rev. E},\n  volume = {105},\n  issue = {6},\n  pages = {065302},\n  numpages = {22},\n  year = {2022},\n  month = {Jun},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.105.065302},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.105.065302}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more detailed description of the algorithms used in this package will appear in a future publication.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this package was supported by the National Science Foundation under Award number OAC-2410280 and the Simons Foundation.","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"}]
}
