var documenterSearchIndex = {"docs":
[{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"section"},{"location":"examples/ossh_chain/#Optical-Su-Schrieffer-Heeger-Chain","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by\n\nbeginalign*\nhatH = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\n          - sum_sigmai t-alpha(hatX_i+1-hatX_i) (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 24, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"Nrv\"] = Nrv\n        metadata[\"maxiter\"] = maxiter\n        metadata[\"tol\"] = tol\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n        metadata[\"hmc_iters\"] = 0.0\n        metadata[\"reflection_iters\"] = 0.0\n        metadata[\"swap_iters\"] = 0.0\n        metadata[\"measurement_iters\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                                basis_vecs   = [[0.0]])\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L],\n            periodic = [true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond for a 1D chain.\n        bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n        # Add this bond to the model, by adding it to the ModelGeometry type.\n        bond_id = add_bond!(model_geometry, bond)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond], # defines hopping\n            t_mean = [t],     ## defines corresponding hopping amplitude\n            μ = μ,            ## set chemical potential\n            ϵ_mean = [0.]     ## set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to live on each site in the lattice.\n        phonon = PhononMode(\n            basis_vec = [0.0],\n            Ω_mean = Ω\n        )\n\n        # Add optical ssh phonon to electron-phonon model.\n        phonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅(Xᵢ₊₁-Xᵢ).\n        ossh_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_id, phonon_id),\n            bond = bond,\n            α_mean = α\n        )\n\n        # Add optical SSH coupling to the electron-phonon model.\n        ossh_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_id, bond_id),\n            ]\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = update + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 9,\n        delimiter = \", \"\n    )\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"1d) Honeycomb Holstein Model with Density Tuning","text":"Download this example as a Julia script.","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#1d)-Honeycomb-Holstein-Model-with-Density-Tuning","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"1d) Honeycomb Holstein Model with Density Tuning","text":"In this example we demonstrate how to introduce chemical potential and density tuning to the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial. Specifically, we show how to use the algorithm introduced in Phys. Rev. E 105, 045311 for dynamically adjusting the chemical potential during the simulation in order to achieve a target electron density or filling fraction.","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Import-Packages","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Import Packages","text":"Compared to the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial, we now need to import the MuTuner.jl package, which is reexported by SmoQyDQMC.jl\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.MuTuner as mt\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Specify-simulation-parameters","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Specify simulation parameters","text":"Here we introduce the keyword argument n to the run_simulation function which specifies the target electron density we want to achieve in the simulation. Now the μ argument specifies the initial chemical potential we begin the simulation with, but of course it will be adjusted during the simulation to achieve the target density n.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    n, # Target density.\n    μ, # Initial chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 25, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation-metadata","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation metadata","text":"Here it is useful to record the initial chemical potential μ used during the simulation in the metadata dictionary.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"N_therm\"] = N_therm  # Number of thermalization updates\n        metadata[\"N_measurements\"] = N_measurements  # Total number of measurements and measurement updates\n        metadata[\"N_bins\"] = N_bins # Number of times bin-averaged measurements are written to file\n        metadata[\"maxiter\"] = maxiter # Maximum number of conjugate gradient iterations\n        metadata[\"tol\"] = tol # Tolerance used for conjugate gradient solves\n        metadata[\"Nt\"] = Nt # Number of time-steps in HMC update\n        metadata[\"Nrv\"] = Nrv # Number of random vectors used to estimate fermionic correlation functions\n        metadata[\"seed\"] = seed  # Random seed used to initialize random number generator in simulation\n        metadata[\"hmc_acceptance_rate\"] = 0.0 # HMC acceptance rate\n        metadata[\"reflection_acceptance_rate\"] = 0.0 # Reflection update acceptance rate\n        metadata[\"swap_acceptance_rate\"] = 0.0 # Swap update acceptance rate\n        metadata[\"hmc_iters\"] = 0.0 # Avg number of CG iterations per solve in HMC update.\n        metadata[\"reflection_iters\"] = 0.0 # Avg number of CG iterations per solve in reflection update.\n        metadata[\"swap_iters\"] = 0.0 # Avg number of CG iterations per solve in swap update.\n        metadata[\"measurement_iters\"] = 0.0 # Avg number of CG iterations per solve while making measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n        # Define lattice vectors.\n        a1 = [+3/2, +√3/2]\n        a2 = [+3/2, -√3/2]\n\n        # Define basis vectors for two orbitals in the honeycomb unit cell.\n        r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n        r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [a1, a2],\n            basis_vecs   = [r1, r2]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set nearest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean         = [t, t, t], # defines corresponding hopping amplitude\n            μ              = μ, # set chemical potential\n            ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(\n            basis_vec = r1,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on the second sublattice.\n        phonon_2 = PhononMode(\n            basis_vec = r2,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_1_id,\n            orbital_id = 1,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define second local Holstein coupling for second phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_2_id,\n            orbital_id = 2,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the second local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model-parameters","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model parameters","text":"In this section we need to make use of the MuTuner.jl package, initializing an instance of the MuTuner.MuTunerLogger type using the MuTuner.init_mutunerlogger function. Note that we use the LatticeUtilities.nsites function to calculate the total number of orbitals in our system.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize MuTunerLogger type that will be used to dynamically adjust the\n        # chemical potential during the simulation.\n        chemical_potential_tuner = mt.init_mutunerlogger(\n            target_density = n,\n            inverse_temperature = β,\n            system_size = lu.nsites(unit_cell, lattice),\n            initial_chemical_potential = μ,\n            complex_sign_problem = false\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-measurements","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize measurement of electron Green's function traced\n        # over both orbitals in the unit cell.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"tr_greens\",\n            correlation = \"greens\",\n            id_pairs = [(1,1), (2,2)],\n            coefficients = [1.0, 1.0],\n            time_displaced = true,\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Write-first-checkpoint","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Write first checkpoint","text":"Here we need to add the MuTuner.MuTunerLogger instance chemical_potential_tuner to the checkpoint file.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Load-checkpoint","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Load checkpoint","text":"Here we need to make sure to load the MuTuner.MuTunerLogger instance chemical_potential_tuner from the checkpoint file.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        chemical_potential_tuner = checkpoint[\"chemical_potential_tuner\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-DQMC-simulation","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-EFA-PFF-HMC-Updates","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Setup EFA-PFF-HMC Updates","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Thermalize-system","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Thermalize system","text":"Here we need to add a call to the SmoQyDQMC.update_chemical_potential! function after completing the updates but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Update the chemical potential to achieve the target density.\n        update_chemical_potential!(\n            fermion_det_matrix, greens_estimator;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Make-measurements","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Make measurements","text":"Here we need to add a call to the SmoQyDQMC.update_chemical_potential! function after making and writing measurements but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Update the chemical potential to achieve the target density.\n        update_chemical_potential!(\n            fermion_det_matrix, greens_estimator;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = update + 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Merge-binned-data","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Record-simulation-metadata","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Record simulation metadata","text":"Here we can add a call to the SmoQyDQMC.save_density_tuning_profile, which records the full history of the chemical potential and density tuning process.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Save the density tuning profile to file.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Post-process-results","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Post-process results","text":"No changes need to made to this section of the code from the previous 1c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Execute-script","page":"1d) Honeycomb Holstein Model with Density Tuning","title":"Execute script","text":"Here we add an additional command line argument to specify the target density n we want to achieve in the simulation. Now the μ command line argument specifies the initial chemical potential we begin the simulation with. For instance, a simulation can be run with the command\n\nmpiexecjl -n 16 julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5\n\nor\n\nsrun julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5\n\nwhere the target density is langle n rangle = 08 and the initial chemical potential is mu = 00.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Run the simulation.\n    run_simulation(\n        MPI.COMM_WORLD;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        n = parse(Float64, ARGS[4]), # Target density.\n        μ = parse(Float64, ARGS[5]), # Initial chemical potential.\n        L = parse(Int, ARGS[6]), # System size.\n        β = parse(Float64, ARGS[7]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[8]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[9]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[10]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[11]), # Frequency with which checkpoint files are written in hours.\n    )\nend","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Fermion-Determinant-Matrix","page":"API","title":"Fermion Determinant Matrix","text":"FermionDetMatrix\nSymFermionDetMatrix\nAsymFermionDetMatrix","category":"section"},{"location":"api/#Preconditioners","page":"API","title":"Preconditioners","text":"KPMPreconditioner\nSymKPMPreconditioner\nAsymKPMPreconditioner","category":"section"},{"location":"api/#Monte-Carlo-Update-Methods","page":"API","title":"Monte Carlo Update Methods","text":"PFFCalculator\nEFAPFFHMCUpdater\nhmc_update!\nreflection_update!\nswap_update!\nradial_update!","category":"section"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"GreensEstimator\nmake_measurements!","category":"section"},{"location":"api/#Chemical-Potential-Tuning","page":"API","title":"Chemical Potential Tuning","text":"update_chemical_potential!","category":"section"},{"location":"api/#SmoQyElPhQMC.FermionDetMatrix","page":"API","title":"SmoQyElPhQMC.FermionDetMatrix","text":"FermionDetMatrix{T<:Number, E<:AbstractFloat}\n\nA abstract type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere B_l are propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.SymFermionDetMatrix","page":"API","title":"SmoQyElPhQMC.SymFermionDetMatrix","text":"SymFermionDetMatrix{T<:Number, E<:AbstractFloat} <: FermionDetMatrix{T,E}\n\nA type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere\n\nB_l = left e^-Deltatau K_l2 right^dagger e^-Deltatau V_l e^-Deltatau K_l2\n\nare Hermitian (symmetric if real) propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice. Here the matrix e^-Deltatau K_l2 is  approximated using the non-hermitian checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.SymFermionDetMatrix-Union{Tuple{FermionPathIntegral{T, E}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.SymFermionDetMatrix","text":"SymFermionDetMatrix(\n    fermion_path_integral::FermionPathIntegral{T, E};\n    maxiter::Int = (fermion_path_integral.N * fermion_path_integral.Lτ),\n    tol::E = 1e-6\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the SymFermionDetMatrix type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.AsymFermionDetMatrix","page":"API","title":"SmoQyElPhQMC.AsymFermionDetMatrix","text":"AsymFermionDetMatrix{T<:Number, E<:AbstractFloat} <: FermionDetMatrix{T, E}\n\nA type to represent fermion determinant matrix\n\nM = left(beginarrayccccc\n    I        B_0\n    -B_1  I\n     -B_2  ddots\n       ddots  ddots\n         -B_L_tau-1  I\nendarrayright)\n\nwhere\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nare Hermitian (symmetric if real) propagator matrices for imaginary-time slice tau = Deltatau cdot l given an inverse temperature beta = Deltatau cdot L_tau. A Fermion determinant matrix M will be N L_tau times N L_tau, where each propagator matrix B_l is N times N, where N is the number of orbitals in the lattice. Note that e^-Deltatau K_l is represented using the non-hermitian checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.AsymFermionDetMatrix-Union{Tuple{FermionPathIntegral{T, E}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.AsymFermionDetMatrix","text":"AsymFermionDetMatrix(\n    fermion_path_integral::FermionPathIntegral{T, E};\n    maxiter::Int = (fermion_path_integral.N * fermion_path_integral.Lτ),\n    tol::E = 1e-6\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the AsymFermionDetMatrix type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.KPMPreconditioner","page":"API","title":"SmoQyElPhQMC.KPMPreconditioner","text":"abstract type KPMPreconditioner{T<:Number, E<:AbstractFloat} end\n\nAbstract type representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix. Here, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.KPMPreconditioner-Union{Tuple{FermionDetMatrix{T}}, Tuple{E}, Tuple{T}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.KPMPreconditioner","text":"KPMPreconditioner(\n    fermion_det_matrix::FermionDetMatrix{T};\n    # Keyword Arguments\n    rng::AbstractRNG = Random.default_rng(),\n    rbuf::E = 0.10,\n    n::Int = 20,\n    a1::E = 1.0,\n    a2::E = 1.0\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize and return an instance of either the SymKPMPreconditioner or AsymKPMPreconditioner type.\n\nArguments\n\nfermion_det_matrix::FermionDetMatrix{T}: Fermion determinant matrix.\n\nKeyword Arguments\n\nrng::AbstractRNG = Random.default_rng(): Random number generator.\nrbuf::E = 0.10: Relative buffer applied to eigenvalue bounds of barB calculated by Lanczos.\nn::Int = 20: Number of Lanczos iterations used to approximate eigenvalue bounds.\na1::E = 1.0: Controls maximum order of kpm expansion.\na2::E = 1.0: Controls minimum order of kpm expansion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.SymKPMPreconditioner","page":"API","title":"SmoQyElPhQMC.SymKPMPreconditioner","text":"mutable struct SymKPMPreconditioner{T, E, Tfft, Tifft} <: KPMPreconditioner{T, E}\n\nType representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix defined using the symmetric propagator definition\n\nB_l = e^-Deltatau K_l2 e^-Deltatau V_l e^-Deltatau K_l2\n\nHere, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.AsymKPMPreconditioner","page":"API","title":"SmoQyElPhQMC.AsymKPMPreconditioner","text":"mutable struct AsymKPMPreconditioner{T, E, Tfft, Tifft} <: KPMPreconditioner{T, E}\n\nType representing the KPM preconditioner appearing in the left-preconditioned linear system\n\nP^-1 cdot left M^dagger M^phantomdagger right cdot x = P^-1 cdot b\n\nthat is solved for using the Conjugate Gradient method, where M is the fermion determinant matrix defined using the asymmetric propagator definition\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nHere, a KPM preconditioner represents\n\nP^-1 = left barM^dagger barM^phantomdagger right^-1\n\nwith a Chebyshev expansion in powers of\n\nbarB = frac1L_tau sum_l=0^L_tau-1 B_l\n\nwhere\n\nbarM = left(beginarrayccccc\n    I        barB\n    -barB  I\n     -barB  ddots\n       ddots  ddots\n         -barB  I\nendarrayright)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.PFFCalculator","page":"API","title":"SmoQyElPhQMC.PFFCalculator","text":"PFFCalculator{T<:AbstractFloat}\n\nThe PFFCalculator type, short for pseudo-fermion field calculator, is for facilitating the sampling the pseudo-fermion fields Phi, evaluate the fermionic action S_f and calculating it's partial derivatives partial S_fpartial x_taui with respect to each phonon field x_taui\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.PFFCalculator-Union{Tuple{E}, Tuple{T}, Tuple{ElectronPhononParameters{T, E}, FermionDetMatrix{T, E}}} where {T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.PFFCalculator","text":"PFFCalculator(\n    # Arguments\n    electron_phonon_parameters::ElectronPhononParameters{T},\n    fermion_det_matrix::FermionDetMatrix{T};\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the PFFCalculator type used for calculating the pseudo-fermion fields Phi. The tol and maxiter keywords specify the tolerance and maximum number of iterations used when performing conjugate gradient solves to evaluate the fermionic action given the current fields Phi.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyElPhQMC.EFAPFFHMCUpdater","page":"API","title":"SmoQyElPhQMC.EFAPFFHMCUpdater","text":"struct EFAPFFHMCUpdater{T<:AbstractFloat, PFFT, PIFFT}\n\nType to define how to perform an Hybrid/Hamiltonian Monte Carlo (HMC) updates of the phonon fields using a fermionic action formulated by introducing a complex pseudofermion field (PFF) \\Phi. Exact Fourier Acceleration (EFA) is also used to more efficiently sample the phonon fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.EFAPFFHMCUpdater-Tuple{}","page":"API","title":"SmoQyElPhQMC.EFAPFFHMCUpdater","text":"EFAPFFHMCUpdater(;\n    # Keyword Arguments\n    electron_phonon_parameters::ElectronPhononParameters{T},\n    Nt::Int,\n    Δt::E = π/(2*Nt),\n    η::E = 0.0,\n    δ::E = 0.05\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize an instance of EFAPFFHMCUpdater type, defining an EFA-PFF-HMC update.\n\nKeyword Arguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T}: Parameters defining the electron-phonon model.\nNt::Int: Number of HMC time-steps.\nΔt::E: Time-step for HMC update.\nη::E = 0.0: Regularization parameter for EFA.\nδ::E = 0.05: Fractional noise to add to the time-step Δt.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAPFFHMCUpdater{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    pff_calculator::PFFCalculator{E},\n    rng::AbstractRNG,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ,\n    tol_action::E = fermion_det_matrix.cg.tol,\n    tol_force::E = sqrt(fermion_det_matrix.cg.tol),\n    max_iter::Int = fermion_det_matrix.cg.maxiter,\n    preconditioner = I\n) where {T, E}\n\nPerform an EFA-PFF-HMC update to the phonon fields. Acronym EFA-PFF-HMC stands for pseudofermion field (PPF) Hamiltonian/hyrbid Monte Carlo (HMC) update with exact Fourier acceleration (EFA) used to reduce autocorrelation times.\n\nKeyword Arguments with Default Values\n\nrecenter!::Function = identity: Function to recenter the phonon fields after the update.\nNt::Int = hmc_updater.Nt: Number of HMC time-steps.\nΔt::E = hmc_updater.Δt: Time-step for HMC update.\nδ::E = hmc_updater.δ: Fractional noise to add to the time-step Δt.\ntol_action::E = fermion_det_matrix.cg.tol: Tolerance used in CG solve to evaluate fermionic action.\ntol_force::E = sqrt(fermion_det_matrix.cg.tol): Tolerance used in CG solve to evaluate derivative of fermionic action.\nmax_iter::Int = fermion_det_matrix.cg.maxiter: Maximum number of iterations for CG solve.\npreconditioner = I: Preconditioner used in CG solves.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.reflection_update!","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_types = nothing\n) where {T<:Number, E<:AbstractFloat}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x The argument phonon_types specifies the phonon ID's that are included for randomly sampling a phonon mode in the lattice to perform a swap update on. If phonon_types = nothing, then all types of phonon modes are included. This function returns a tuple containing (accepted, iters), where accepted is a boolean indicating whether the update was accepted or rejected, and iters is the number of CG iterations performed to calculate the fermionic action.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.swap_update!","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_type_pairs = nothing\n) where {T<:Number, E<:AbstractFloat}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. The argument phonon_type_pairs specifies pairs phonon IDs that are used to randomly samples a pairs of phonon modes. If phonon_type_pairs = nothing, then all possible pairs of phonon types/IDs are allowed. This function returns a tuple containing (accepted, iters), where accepted is a boolean indicating whether the update was accepted or rejected, and iters is the number of CG iterations performed to calculate the fermionic action.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.radial_update!","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    pff_calculator::PFFCalculator{E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    rng::AbstractRNG,\n    preconditioner = I,\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter,\n    phonon_id::Union{Nothing,Int} = nothing,\n    σ::E = 1.0\n) where {T<:Number, E<:AbstractFloat}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyElPhQMC.GreensEstimator","page":"API","title":"SmoQyElPhQMC.GreensEstimator","text":"GreensEstimator{\n    T<:AbstractFloat, D, Dp1, Dp3,\n    Gfft<:AbstractFFTs.Plan, Gifft<:AbstractFFTs.Plan,\n    Cfft<:AbstractFFTs.Plan, Cifft<:AbstractFFTs.Plan,\n}\n\nThis type is used to compute stochastic estimates of the Green's function and other correlation functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyElPhQMC.GreensEstimator-Union{Tuple{E}, Tuple{T}, Tuple{D}, Tuple{FermionDetMatrix{T, E}, ModelGeometry{D, E}}} where {D, T<:Number, E<:AbstractFloat}","page":"API","title":"SmoQyElPhQMC.GreensEstimator","text":"GreensEstimator(\n    # Arguments\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    model_geometry::ModelGeometry{D,E};\n    # Keyword Arguments\n    Nrv::Int = 10,\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    maxiter::Int = fermion_det_matrix.cgs.maxiter,\n    tol::E = fermion_det_matrix.cgs.tol\n) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize an instance of the type GreensEstimator.\n\nArguments\n\nfermion_det_matrix::FermionDetMatrix{T,E}: Fermion determinant matrix.\nmodel_geometry::ModelGeometry{D,E}: Defines model geometry.\n\nKeyword Arguments\n\nNrv::Int = 10: Number of random vectors used to approximate Green's function.\npreconditioner = I: Preconditioner used to solve linear system.\nrng = Random.default_rng(): Random number generator.\nmaxiter::Int = fermion_det_matrix.cgs.maxiter: Maximum number of iterations for linear solver.\ntol::E = fermion_det_matrix.cgs.tol: Tolerance for linear solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(\n    measurement_container::NamedTuple,\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    greens_estimator::GreensEstimator{E,D};\n    # Keyword Arguments Start Here\n    model_geometry::ModelGeometry{D,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    tol::E = fermion_det_matrix.cg.tol,\n    maxiter::Int = fermion_det_matrix.cg.maxiter\n) where {T<:Number, E<:AbstractFloat, D}\n\nMake all measurements.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(\n    # ARGUMENTS\n    fermion_det_matrix::FermionDetMatrix{T,E},\n    greens_estimator::GreensEstimator{E,D};\n    # KEYWORD ARGUMENTS\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    preconditioner = I,\n    rng::AbstractRNG = Random.default_rng(),\n    update_greens_estimator::Bool = true,\n    tol::E = fermion_det_matrix.cgs.tol,\n    maxiter::Int = fermion_det_matrix.cgs.maxiter\n) where {D, T<:Number, E<:AbstractFloat}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. If update_greens_estimator = true, then greens_estimator is initialized to reflect the current state of the fermion_det_matrix.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/holstein_honeycomb/","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"Download this example as a Julia script.","category":"section"},{"location":"tutorials/holstein_honeycomb/#1a)-Honeycomb-Holstein-Model","page":"1a) Honeycomb Holstein Model","title":"1a) Honeycomb Holstein Model","text":"In this example we reimplement the SmoQyDQMC tutorial on simulating the Holstein model on a Honeycomb lattice using SmoQyElPhQMC. The Holstein Hamiltonian is given by\n\nbeginalign*\nhatH =  -t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n- mu sum_isigma hatn_sigmai \n + frac12 M Omega^2 sum_i hatX_i^2 + sum_i frac12M hatP_i^2\n+ alpha sum_i hatX_i (hatn_uparrowi + hatn_downarrowi - 1)\nendalign*\n\nwhere hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. Here mu is the chemical potential and  t is the nearest-neighbor hopping amplitude, with the sum over langle ij rangle denoting a sum over all nearest-neighbor pairs of sites. A local dispersionless phonon mode is then placed on each site in the lattice, with hatX_i and hatP_i the corresponding phonon position and momentum operator on site i in the lattice. The phonon mass and energy are denoted M and Omega respectively. Lastly, the phonon displacement hatX_i couples to the total local density hatn_uparrowi + hatn_downarrowi with the parameter alpha controlling the strength of this coupling.","category":"section"},{"location":"tutorials/holstein_honeycomb/#Import-packages","page":"1a) Honeycomb Holstein Model","title":"Import packages","text":"First, we begin by importing the necessary packages. The SmoQyElPhQMC package is built as an extension package on top of SmoQyDQMC, enabling the simulation of strictly spin-symmetric electron-phonon models. Therefore, in addition to importing SmoQyElPhQMC, we also need to import SmoQyDQMC. The SmoQyDQMC package also then reexports the LatticeUtilities package, which we will use to define the lattice geometry for our model.\n\nLastly, we use the Standard Library packages Random and Printf for random number generation and C-style string formatting, respectively.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing LinearAlgebra\nusing Random\nusing Printf","category":"section"},{"location":"tutorials/holstein_honeycomb/#Specify-simulation-parameters","page":"1a) Honeycomb Holstein Model","title":"Specify simulation parameters","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations. The specific meaning of each argument will be discussed in later sections of the tutorial.\n\n# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements to make.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 24, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation","page":"1a) Honeycomb Holstein Model","title":"Initialize simulation","text":"In this first part of the script we name and initialize our simulation, creating the data folder our simulation results will be written to. This is done by initializing an instances of the SmoQyDQMC.SimulationInfo type.\n\nNote that the write_bins_concurrent keyword arguments controls whether or not binned simulation measurement data is written to HDF5 file during the simulation, or held in memory and only written to file once the simulation is complete. Here we decide how to set write_bins_concurrent based on the system size being simulated. This is because when performing simulations of small systems that do not take very long, writing data to file too frequently can sometimes cause network latency problems on clusters and HPC systems. However, for larger systems that take longer to simulate, you are not limited by file IO frequency but rather by available memory, so writing data to file more frequently is preferred in these cases.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation-metadata","page":"1a) Honeycomb Holstein Model","title":"Initialize simulation metadata","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary. Think of the metadata dictionary as a place to record any additional information during the simulation that will not otherwise be automatically recorded and written to file.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm  # Number of thermalization updates\n    metadata[\"N_measurements\"] = N_measurements  # Total number of measurements and measurement updates\n    metadata[\"N_bins\"] = N_bins # Number of times bin-averaged measurements are written to file\n    metadata[\"maxiter\"] = maxiter # Maximum number of conjugate gradient iterations\n    metadata[\"tol\"] = tol # Tolerance used for conjugate gradient solves\n    metadata[\"Nt\"] = Nt # Number of time-steps in HMC update\n    metadata[\"Nrv\"] = Nrv # Number of random vectors used to estimate fermionic correlation functions\n    metadata[\"seed\"] = seed  # Random seed used to initialize random number generator in simulation\n\nHere we also update variables to keep track of the acceptance rates for the various types of Monte Carlo updates that will be performed during the simulation. This will be discussed in more detail in later sections of the tutorial.\n\n    metadata[\"hmc_acceptance_rate\"] = 0.0 # HMC acceptance rate\n    metadata[\"reflection_acceptance_rate\"] = 0.0 # Reflection update acceptance rate\n    metadata[\"swap_acceptance_rate\"] = 0.0 # Swap update acceptance rate\n\nInitialize variables to record the average number of CG iterations for each type of update and measurements.\n\n    metadata[\"hmc_iters\"] = 0.0 # Avg number of CG iterations per solve in HMC update.\n    metadata[\"reflection_iters\"] = 0.0 # Avg number of CG iterations per solve in reflection update.\n    metadata[\"swap_iters\"] = 0.0 # Avg number of CG iterations per solve in swap update.\n    metadata[\"measurement_iters\"] = 0.0 # Avg number of CG iterations per solve while making measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-model","page":"1a) Honeycomb Holstein Model","title":"Initialize model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters the phonon energy Omega (Ω), electron-phonon coupling alpha (α), chemical potential mu (μ), and lattice size L (L). The nearest-neighbor hopping amplitude and phonon mass are normalized to unity, t = M = 1.\n\nFirst we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the LatticeUtilities.UnitCell and LatticeUtilities.Lattice types, respectively. Lastly, we define various instances of the LatticeUtilities.Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the SmoQyDQMC.ModelGeometry type.\n\n    # Define lattice vectors.\n    a1 = [+3/2, +√3/2]\n    a2 = [+3/2, -√3/2]\n\n    # Define basis vectors for two orbitals in the honeycomb unit cell.\n    r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n    r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [a1, a2],\n        basis_vecs   = [r1, r2]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\nNext we specify the Honeycomb tight-binding term in our Hamiltonian with the SmoQyDQMC.TightBindingModel type.\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\nNow we need to initialize the electron-phonon part of the Hamiltonian with the ElectronPhononModel type.\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\nThen we need to define and add two types phonon modes to the model, one for each orbital in the Honeycomb unit cell, using the SmoQyDQMC.PhononMode type and SmoQyDQMC.add_phonon_mode! function.\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(\n        basis_vec = r1,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on the second sublattice.\n    phonon_2 = PhononMode(\n        basis_vec = r2,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\nNow we need to define and add a local Holstein couplings to our model for each of the two phonon modes in each unit cell using the SmoQyDQMC.HolsteinCoupling type and SmoQyDQMC.add_holstein_coupling! function.\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_1_id,\n        orbital_id = 1,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define second local Holstein coupling for second phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_2_id,\n        orbital_id = 2,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the second local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )\n\nLastly, the SmoQyDQMC.model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-model-parameters","page":"1a) Honeycomb Holstein Model","title":"Initialize model parameters","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the SmoQyDQMC.TightBindingModel and SmoQyDQMC.ElectronPhononModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC and SmoQyElPhQMC supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize separate parameter values for each unit cell in the lattice. For instance, we need to initialize a separate number to represent the on-site energy for each orbital in our finite lattice.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-measurements","page":"1a) Honeycomb Holstein Model","title":"Initialize measurements","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )\n\nIt is also useful to initialize more specialized composite correlation function measurements.\n\nFirst, it can be useful to measure the time-displaced single-particle electron Green's function traced over both orbitals in the unit cell. We can easily implement this measurement using the SmoQyDQMC.initialize_composite_correlation_measurement! function, as shown below.\n\n    # Initialize measurement of electron Green's function traced\n    # over both orbitals in the unit cell.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"tr_greens\",\n        correlation = \"greens\",\n        id_pairs = [(1,1), (2,2)],\n        coefficients = [1.0, 1.0],\n        time_displaced = true,\n    )\n\nAdditionally, to detect the formation of charge-density wave order where the electrons preferentially localize on one of the two sub-lattices of the honeycomb lattice, it is useful to measure the correlation function\n\nC_textcdw(mathbfrtau) = frac1L^2sum_mathbfi langle hatPhi^dagger_mathbfi+mathbfr(tau) hatPhi^phantomdagger_mathbfi(0) rangle\n\nwhere\n\nhatPhi_mathbfi(tau) = hatn_mathbfiA(tau) - hatn_mathbfiB(tau)\n\nand hatn_mathbfigamma = (hatn_uparrowmathbfio + hatn_downarrowmathbfio) is the total electron number operator for orbital gamma in AB in unit cell mathbfi. It is then also useful to calculate the corresponding structure factor S_textcdw(mathbfqtau) and susceptibility chi_textcdw(mathbfq) Again, this can all be easily calculated using the SmoQyDQMC.initialize_composite_correlation_measurement! function, as shown below.\n\n    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        displacement_vecs = [[0.0, 0.0], [0.0, 0.0]],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Setup-QMC-Simulation","page":"1a) Honeycomb Holstein Model","title":"Setup QMC Simulation","text":"This section of the code sets up the QMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.\n\nThis section of code is perhaps the most opaque and difficult to understand, and will be discussed in more detail once written. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a QMC simulation for a different Hamiltonian.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\nAt the start of this section, an instance of the FermionPathIntegral type was allocated and then initialized. Recall that after discretizing the imaginary-time axis and applying the Suszuki-Trotter approximation, the resulting Hamiltonian is quadratic in fermion creation and annihilation operators, but fluctuates in imaginary-time as a result of the phonon fields. Therefore, this Hamiltonian may be expressed as\n\nhatH_l = sum_sigma hatmathbfc_sigma^dagger left H_sigmal right hatmathbfc_sigma\n= sum_sigma hatmathbfc_sigma^dagger left K_sigmal + V_sigmal right hatmathbfc_sigma\n\nat imaginary-time tau = Deltatau cdot l, where hatmathbfc_sigma  (hatmathbfc_sigma^dagger) is a column (row) vector of spin-sigma electron annihilation (creation) operators for each orbital in the lattice. Here H_sigmal is the spin-sigma Hamiltonian matrix for imaginary-time tau, which can be expressed as the sum of the electron kinetic and potential energy matrices K_sigmal and V_sigmal, respectively.\n\nThe purpose of the SmoQyDQMC.FermionPathIntegral type is to contain the minimal information required to reconstruct each K_sigmal and V_sigmal matrices. Here we only need to allocate a single instance of the SmoQyDQMC.FermionPathIntegral type as we assume spin symmetry. The SmoQyDQMC.FermionPathIntegral instance is first allocated and initialized to reflect just the non-interacting component of the Hamiltonian. Then the subsequent SmoQyDQMC.initialize! call modifies the SmoQyDQMC.FermionPathIntegral to reflect the contribution from the initial phonon field configuration.\n\nNext we initialize an instance of the SymFermionDetMatrix type of represent the Fermion determinant matrix, where is an inherited type from the abstract FermionDetMatrix type. We could have used an instance of the AsymFermionDetMatrix here instead if we wanted to.\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\nNow we can initialize an instance of the PFFCalculator type, which is used to sample and store the complex pseudofermion fields Phi and evaluate the fermionic action\n\nS_F(xPhi) = Phi^dagger leftLambda^dagger(x) M^dagger(x) M^phantomdagger(x) Lambda^phantomdagger(x)right^-1 Phi^phantomdagger\n\nwhere M(x) is the fermion determinant matrix and Lambda(x) is a unitary transformation specially chosen to improve sampling. These auxiliary fields result from replacing the fermion determinants by a complex multivariate Gaussian integral\n\ndet M(x)^2 propto int dPhi e^-S_F(xPhi)\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\nEvaluating the fermionic action S(Fx), and its partial derivatives with respect to the phonon fields, requires solving linear system of the form\n\nleft M^dagger(x) M^phantomdagger(x) right v = b\n\nwhich is done using the conjugate gradient (CG) method. This is the most expensive operation in the QMC simulation. We use the KPMPreconditioner type to accelerate the convergence of the CG calculations, thereby accelerating the simulations.\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\nFinally, we initialize an instance of the GreensEstimator type, which is for estimating fermionic correlation functions when making measurements.\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)","category":"section"},{"location":"tutorials/holstein_honeycomb/#holstein_square_efa-hmc_updates","page":"1a) Honeycomb Holstein Model","title":"Setup EFA-PFF-HMC Updates","text":"Before we begin the simulation, we also want to initialize an instance of the EFAPFFHMCUpdater type, which will be used to perform hybrid Monte Carlo (HMC) updates to the phonon fields that use exact fourier acceleration (EFA) to further reduce autocorrelation times.\n\nThe two main parameters that need to be specified are the time-step size Delta t and number of time-steps N_t performed in the HMC update, with the corresponding integrated trajectory time then equalling T_t = N_t cdot Delta t Note that the computational cost of an HMC update is linearly proportional to N_t while the acceptance rate is approximately proportional to 1(Delta t)^2\n\nPrevious studies have shown that a good place to start with the integrated trajectory time T_t is a quarter the period associated with the bare phonon frequency, T_t approx frac14 left( frac2piOmega right) = pi(2Omega) However, in our implementation we effectively normalize all of the bare phonon frequencies to unity in the dynamics. Therefore, a good choice for the trajectory time in our implementation is simply T_t = pi2. Therefore, in most cases you simply need to select a value for N_t and then use the default assigned time-step Delta t = pi  (2 N_t), such that the trajectory length is held fixed at T_t = pi2. With this convention the computational cost of performing updates still increases linearly with N_t, but the acceptance rate also increases with N_t. Note that it can be important to keep the acceptance rate for the HMC updates above sim 90 to avoid numerical instabilities from occuring.\n\nBased on user experience, a good (conservative) starting place is to set the number of time-steps to N_t approx 10 Then, if the acceptance rate is too low you increase N_t which implicitly results in a reduction of Delta t Conversely, if the acceptance rate is very high (gtrsim 99  ) it may be useful to decrease N_t, thereby increasing Delta t as this will reduce the computational cost of performing an EFA-HMC update.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Thermalize-system","page":"1a) Honeycomb Holstein Model","title":"Thermalize system","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. In addition to EFA-HMC updates that will be performed using the EFAPFFHMCUpdater type initialized above and the hmc_update! function below, we will also perform reflection and swap updates using the reflection_update! and swap_update! functions respectively.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb/#Make-measurements","page":"1a) Honeycomb Holstein Model","title":"Make measurements","text":"In this next section of code we continue to sample the phonon fields as above, but will also begin making measurements as well. For more discussion on the overall structure of this part of the code, refer to here.\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over bins.\n    for measurement in 1:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb/#Merge-binned-data","page":"1a) Honeycomb Holstein Model","title":"Merge binned data","text":"At this point the simulation is essentially complete, with all updates and measurements having been performed. However, the binned measurement data resides in many separate HDF5 files currently. Here we will merge these separate HDF5 files into a single file containing all the binned data using the SmoQyDQMC.merge_bins function.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Record-simulation-metadata","page":"1a) Honeycomb Holstein Model","title":"Record simulation metadata","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the various types of updates we performed, as well as write the simulation metadata to file, including the contents of the metadata dictionary.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Post-process-results","page":"1a) Honeycomb Holstein Model","title":"Post-process results","text":"In this final section of code we post-process the binned data. This includes calculating the final estimates for the mean and error of all measured observables, which will be written to an HDF5 file using the SmoQyDQMC.process_measurements function. Inside this function the binned data gets further re-binned into n_bins, where n_bins is any positive integer satisfying the constraints (N_bins ≥ n_bin) and (N_bins % n_bins == 0). Note that the SmoQyDQMC.process_measurements function has many additional keyword arguments that can be used to control the output. For instance, in this example in addition to writing the statistics to an HDF5 file, we also export the statistics to CSV files by setting export_to_csv = true, with additional keyword arguments controlling the formatting of the CSV files. Again, for more information on how to interpret the output refer the Simulation Output Overview page.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\nA common measurement that needs to be computed at the end of a DQMC simulation is something called the correlation ratio with respect to the ordering wave-vector for a specified type of structure factor measured during the simulation. In the case of the honeycomb Holstein model, we are interested in measuring the correlation ratio\n\nR_textcdw(0) = 1 - frac14 sum_deltamathbfq fracS_textcdw(0 + deltamathbfq)S_textcdw(0)\n\nwith respect to the equal-time charge density wave (CDW) structure factor S_textcdw(0), where `S_\\text{cdw}(q) is equal-time structure factor corresponding to the composite correlation function C_textcdw(mathbfrtau) defined earlier in this tutorial. Note that the CDW ordering wave-vector is mathbfQ_textcdw = 0 in this case, which describes the electrons preferentially localizing on one of the two sub-lattices of the honeycomb lattice. The sum over deltamathbfq runs over the four wave-vectors that neighbor mathbfQ_textcdw = 0\n\nHere we use the SmoQyDQMC.compute_composite_correlation_ratio function to compute to compute this correlation ratio. Note that the mathbfQ_textcdw = 0 is specified using the q_point keyword argument, and the four neighboring wave-vectors deltamathbfq are specified using the q_neighbors keyword argument. These wave-vectors are specified using the convention described here in the Simulation Output Overview page. Note that because the honeycomb lattice has a C_6 rotation symmetry, each wave-vector in momentum-space has six nearest-neighbor wave-vectors. Below we specify all six wave-vectors that neighbor the mathbfQ_textcdw = 0 wave-vector ordering wave-vector, accounting for the fact that the Brillouin zone is periodic in the reciprocal lattice vectors.\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\nNext, we record the measurement in the metadata dictionary, and then write a new version of the simulation summary TOML file that contains this new information using the SmoQyDQMC.save_simulation_info function.\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"] = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\nNote that as long as the binned data persists the SmoQyDQMC.process_measurements and SmoQyDQMC.compute_correlation_ratio functions can be rerun to recompute the final statistics for the measurements without needing to rerun the simulation.\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb/#Execute-script","page":"1a) Honeycomb Holstein Model","title":"Execute script","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_simulation(\n        sID = parse(Int, ARGS[1]),\n        Ω = parse(Float64, ARGS[2]),\n        α = parse(Float64, ARGS[3]),\n        μ = parse(Float64, ARGS[4]),\n        L = parse(Int, ARGS[5]),\n        β = parse(Float64, ARGS[6]),\n        N_therm = parse(Int, ARGS[7]),\n        N_measurements = parse(Int, ARGS[8]),\n        N_bins = parse(Int, ARGS[9]),\n    )\nend\n\nFor instance, the command\n\n> julia holstein_honeycomb.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nruns a DQMC simulation of a Holstein model on a 3 times 3 unit cell (N = 2 \\times 3^2 = 18 site) honeycomb lattice at half-filling (mu = 0) and inverse temperature beta = 40. The phonon energy is set to Omega = 10 and the electron-phonon coupling is set to alpha = 15 In the DQMC simulation, 5,000 EFA-HMC, reflection and swap updates are performed to thermalize the system. Then an additional 10,000 such updates are performed, after each of set of which measurements are made. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 10,000/100 = 100 sequential measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"1c) Honeycomb Holstein Model with Checkpointing","text":"Download this example as a Julia script.","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#1c)-Honeycomb-Holstein-Model-with-Checkpointing","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"1c) Honeycomb Holstein Model with Checkpointing","text":"In this tutorial we demonstrate how to introduce checkpointing to the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial, allowing for simulations to be resumed if terminated prior to completion.","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Import-packages","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Import packages","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Specify-simulation-parameters","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Specify simulation parameters","text":"Compared to the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial, we have added two new keyword arguments to the run_simulation function:\n\ncheckpoint_freq: When going to write a new checkpoint file, only write one if more than checkpoint_freq hours have passed since the last checkpoint file was written.\nruntime_limit: If after writing a new checkpoint file more than runtime_limit hours have passed since the simulation started, terminate the simulation.\n\nThe runtime_limit = Inf default behavior means there is no runtime limit for the simulation.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 25, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation","text":"We need to make a few modifications to this portion of the code as compared to the previous tutorial in order for checkpointing to work. First, we record need to record the simulation start time, which we do by initializing a variable start_timestamp = time(). Second, we need to convert the checkpoint_freq and runtime_limit from hours to seconds.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation-metadata","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation metadata","text":"At this point we need to introduce branching logic to handle whether a new simulation is being started, or a previous simulation is being resumed. We do this by checking the simulation_info.resuming boolean value. If simulation_info.resuming = true, then we are resuming a previous simulation, while simulation_info.resuming = false indicates we are starting a new simulation. Therefore, the section of code immediately below handles the case that we are starting a new simulation.\n\nWe also introduce and initialize two new variables n_therm = 1 and n_measurements = 1 which will keep track of how many rounds of thermalization and measurement updates have been performed. These two variables will needed to be included in the checkpoint files we write later in the simulation, as they will indicate where to resume a previously terminated simulation.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"N_therm\"] = N_therm  # Number of thermalization updates\n        metadata[\"N_measurements\"] = N_measurements  # Total number of measurements\n        metadata[\"N_bins\"] = N_bins # Number of times bin-averaged measurements are written to file\n        metadata[\"maxiter\"] = maxiter # Maximum number of conjugate gradient iterations\n        metadata[\"tol\"] = tol # Tolerance used for conjugate gradient solves\n        metadata[\"Nt\"] = Nt # Number of time-steps in HMC update\n        metadata[\"Nrv\"] = Nrv # Number of random vectors used to estimate fermionic correlation functions\n        metadata[\"seed\"] = seed  # Random seed used to initialize random number generator in simulation\n        metadata[\"hmc_acceptance_rate\"] = 0.0 # HMC acceptance rate\n        metadata[\"reflection_acceptance_rate\"] = 0.0 # Reflection update acceptance rate\n        metadata[\"swap_acceptance_rate\"] = 0.0 # Swap update acceptance rate\n        metadata[\"hmc_iters\"] = 0.0 # Avg number of CG iterations per solve in HMC update.\n        metadata[\"reflection_iters\"] = 0.0 # Avg number of CG iterations per solve in reflection update.\n        metadata[\"swap_iters\"] = 0.0 # Avg number of CG iterations per solve in swap update.\n        metadata[\"measurement_iters\"] = 0.0 # Avg number of CG iterations per solve while making measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Define lattice vectors.\n        a1 = [+3/2, +√3/2]\n        a2 = [+3/2, -√3/2]\n\n        # Define basis vectors for two orbitals in the honeycomb unit cell.\n        r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n        r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [a1, a2],\n            basis_vecs   = [r1, r2]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set nearest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean         = [t, t, t], # defines corresponding hopping amplitude\n            μ              = μ, # set chemical potential\n            ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(\n            basis_vec = r1,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on the second sublattice.\n        phonon_2 = PhononMode(\n            basis_vec = r2,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_1_id,\n            orbital_id = 1,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define second local Holstein coupling for second phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_2_id,\n            orbital_id = 2,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the second local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model-parameters","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-measurements","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize measurement of electron Green's function traced\n        # over both orbitals in the unit cell.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"tr_greens\",\n            correlation = \"greens\",\n            id_pairs = [(1,1), (2,2)],\n            coefficients = [1.0, 1.0],\n            time_displaced = true,\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Write-first-checkpoint","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Write first checkpoint","text":"This section of code needs to be added so that a first checkpoint file is written before beginning a new simulation. We do this using the SmoQyDQMC.write_jld2_checkpoint function. This function all return the epoch timestamp checkpoint_timestamp corresponding to when the checkpoint file was written.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Load-checkpoint","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Load checkpoint","text":"If we are resuming a simulation that was previously terminated prior to completion, then we need to load the most recent checkpoint file using the SmoQyDQMC.read_jld2_checkpoint function. The contents of the checkpoint file are returned as a dictionary checkpoint by the SmoQyDQMC.read_jld2_checkpoint function. We then extract the contents of the checkpoint file from the checkpoint dictionary.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-DQMC-simulation","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-EFA-PFF-HMC-Updates","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Setup EFA-PFF-HMC Updates","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Thermalize-system","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Thermalize system","text":"The first change we need to make to this section is to have the for-loop iterate from n_therm:N_therm instead of 1:N_therm. The other change we need make to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial is to add a call to the SmoQyDQMC.write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform the thermalization updates. When calling this function we need to pass it the timestamp for the previous checkpoint checkpoint_timestamp so that the function can determine if a new checkpoint file needs to be written. If a new checkpoint file is written then the checkpoint_timestamp variable will be updated to reflect this, otherwise it will remain unchanged.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Make-measurements","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Make measurements","text":"Again, we need to modify the for-loop so that it runs from n_measurements:N_measurements instead of 1:N_measurements. The only other change we need to make to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial is to add a call to the SmoQyDQMC.write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform updates and measurements. Note that we set n_therm = N_therm + 1 when writing the checkpoint file to ensure that when the simulation is resumed the thermalization updates are not repeated.\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Merge-binned-data","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Record-simulation-metadata","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Post-process-results","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Post-process results","text":"From the last 1b) Honeycomb Holstein Model with MPI Parallelization tutorial, we now recommend adding a call to the SmoQyDQMC.rename_complete_simulation function once the results are processed. This function renames the data folder to begin with complete_*, making it simple to identify which simulations ran to completion and which ones need to be resumed from the last checkpoint file. This function also deletes the checkpoint files that were written during the simulation.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"] = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Execute-script","page":"1c) Honeycomb Holstein Model with Checkpointing","title":"Execute script","text":"To execute the script, we have added two new command line arguments allowing for the assignment of both the checkpoint_freq and runtime_limit values. Therefore, a simulation can be run with the command\n\nmpiexecjl -n 16 julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5\n\nor\n\nsrun julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5\n\nRefer to the previous 1b) Honeycomb Holstein Model with MPI Parallelization tutorial for more details on how to run the simulation script using MPI.\n\nIn the example calls above the code will write a new checkpoint if more than 30 minutes (0.5 hours) has passed since the last checkpoint file was written. Note that these same commands are used to both begin a new simulation and also resume a previous simulation. This is a useful feature when submitting jobs on a cluster, as it allows the same job file to be used for both starting new simulations and resuming ones that still need to finish.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]),  # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"1b) Honeycomb Holstein Model with MPI Parallelization","text":"Download this example as a Julia script.","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#1b)-Honeycomb-Holstein-Model-with-MPI-Parallelization","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"1b) Honeycomb Holstein Model with MPI Parallelization","text":"This tutorial will build on the previous 1a) Honeycomb Holstein Model tutorial, demonstrating how to add parallelization with MPI using the MPI.jl package. By this we mean that each MPI process will act as independent walker, running it's own independent DQMC simulation, with the final reported estimates for measured quantities being the average across all walkers.","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Import-packages","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Import packages","text":"We now need to import the MPI.jl package as well.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing LinearAlgebra\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Specify-simulation-parameters","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Specify simulation parameters","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 24, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation","text":"Now when initializing the SmoQyDQMC.SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.\n\nWe also the SmoQyDQMC.initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation-metadata","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation metadata","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm  # Number of thermalization updates\n    metadata[\"N_measurements\"] = N_measurements  # Total number of measurements and measurement updates\n    metadata[\"N_bins\"] = N_bins # Number of times bin-averaged measurements are written to file\n    metadata[\"maxiter\"] = maxiter # Maximum number of conjugate gradient iterations\n    metadata[\"tol\"] = tol # Tolerance used for conjugate gradient solves\n    metadata[\"Nt\"] = Nt # Number of time-steps in HMC update\n    metadata[\"Nrv\"] = Nrv # Number of random vectors used to estimate fermionic correlation functions\n    metadata[\"seed\"] = seed  # Random seed used to initialize random number generator in simulation\n    metadata[\"hmc_acceptance_rate\"] = 0.0 # HMC acceptance rate\n    metadata[\"reflection_acceptance_rate\"] = 0.0 # Reflection update acceptance rate\n    metadata[\"swap_acceptance_rate\"] = 0.0 # Swap update acceptance rate\n    metadata[\"hmc_iters\"] = 0.0 # Avg number of CG iterations per solve in HMC update.\n    metadata[\"reflection_iters\"] = 0.0 # Avg number of CG iterations per solve in reflection update.\n    metadata[\"swap_iters\"] = 0.0 # Avg number of CG iterations per solve in swap update.\n    metadata[\"measurement_iters\"] = 0.0 # Avg number of CG iterations per solve while making measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Define lattice vectors.\n    a1 = [+3/2, +√3/2]\n    a2 = [+3/2, -√3/2]\n\n    # Define basis vectors for two orbitals in the honeycomb unit cell.\n    r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n    r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [a1, a2],\n        basis_vecs   = [r1, r2]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(\n        basis_vec = r1,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on the second sublattice.\n    phonon_2 = PhononMode(\n        basis_vec = r2,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_1_id,\n        orbital_id = 1,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define second local Holstein coupling for second phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_2_id,\n        orbital_id = 2,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the second local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model-parameters","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-measurements","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs of modes.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize measurement of electron Green's function traced\n    # over both orbitals in the unit cell.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"tr_greens\",\n        correlation = \"greens\",\n        id_pairs = [(1,1), (2,2)],\n        coefficients = [1.0, 1.0],\n        time_displaced = true,\n    )\n\n    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-QMC-simulation","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup QMC simulation","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-EFA-PFF-HMC-Updates","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup EFA-PFF-HMC Updates","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Thermalize-system","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Thermalize system","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Make-measurements","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Make measurements","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over bins.\n    for measurement in 1:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Merge-binned-data","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Record-simulation-metadata","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 1a) Honeycomb Holstein Model tutorial.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Post-process-results","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Post-process results","text":"The main change we need to make from the previous 1a) Honeycomb Holstein Model tutorial is to call the SmoQyDQMC.process_measurements and SmoQyDQMC.compute_composite_correlation_ratio functions such that the first argument is the comm object, thereby ensuring a parallelized version of each method is called.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Execute-script","page":"1b) Honeycomb Holstein Model with MPI Parallelization","title":"Execute script","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]) # Number of times bin-averaged measurements are written to file.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend\n\nHere is an example of what the command to run this script might look like:\n\nmpiexecjl -n 16 julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nThis will 16 MPI processes, each running and independent simulation using a different random seed the the final results arrived at by averaging over all 16 walkers. Here mpiexecjl is the MPI executable that can be easily install using the directions found here in the MPI.jl documentation. However, you can substitute a different MPI executable here if one is already configured on your system.\n\nAlso, when submitting jobs via SLURM on a High-Performance Computing (HPC) cluster, if a default MPI executable is already configured on the system, as is frequently the case, then the script can likely be run inside the *.sh job file using the srun command:\n\nsrun julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nThe srun command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.","category":"section"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"section"},{"location":"examples/bssh_chain/#Bond-Su-Schrieffer-Heeger-Chain","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by\n\nbeginalign*\nhatH = sum_i left( frac12MhatP_langle i+1 i rangle^2 + frac12MOmega^2hatX_langle i+1 i rangle^2 right)\n          - sum_sigmai t-alphahatX_langle i+1 i rangle (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and i+1 is given by hatX_langle i+1irangle  (hatP_langle i+1irangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 24, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 100),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"Nrv\"] = Nrv\n        metadata[\"maxiter\"] = maxiter\n        metadata[\"tol\"] = tol\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n        metadata[\"hmc_iters\"] = 0.0\n        metadata[\"reflection_iters\"] = 0.0\n        metadata[\"swap_iters\"] = 0.0\n        metadata[\"measurement_iters\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                                basis_vecs   = [[0.0]])\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L],\n            periodic = [true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond for a 1D chain.\n        bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n        # Add this bond to the model, by adding it to the ModelGeometry type.\n        bond_id = add_bond!(model_geometry, bond)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond], # defines hopping\n            t_mean = [t],     ## defines corresponding hopping amplitude\n            μ = μ,            ## set chemical potential\n            ϵ_mean = [0.]     ## set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each bond in the lattice.\n        phonon = PhononMode(\n            basis_vec = [0.5],\n            Ω_mean = Ω\n        )\n\n        # Add bond ssh phonon to electron-phonon model.\n        phonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon\n        )\n\n        # Define frozen phonon mode with infinite mass.\n        fphonon = PhononMode(\n            basis_vec = [0.0],\n            Ω_mean = Ω,\n            M = Inf # Set phonon mass to infinity.\n        )\n\n        # Add frozen phonon mode to model.\n        fphonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = fphonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅X .\n        bssh_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_id),\n            bond = bond,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_id, bond_id),\n            ]\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = update + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 9,\n        delimiter = \", \"\n    )\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"examples/ossh_square/","page":"Square Optical Su-Schrieffer-Heeger Model","title":"Square Optical Su-Schrieffer-Heeger Model","text":"Download this example as a Julia script.","category":"section"},{"location":"examples/ossh_square/#Square-Optical-Su-Schrieffer-Heeger-Model","page":"Square Optical Su-Schrieffer-Heeger Model","title":"Square Optical Su-Schrieffer-Heeger Model","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_mathbfileft(frac12MhatP_mathbfix^2+frac12MOmega^2hatX_mathbfi^2right) + sum_mathbfileft(frac12MhatP_mathbfiy^2+frac12MOmega^2hatY_mathbfi^2right) \n         - sum_mathbfisigmaleftt-alphaleft(hatX_mathbfi+mathbfx-hatX_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfx^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfx^phantomdaggerright) \n         - sum_mathbfisigmaleftt-alphaleft(hatY_mathbfi+mathbfy-hatY_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfy^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfy^phantomdaggerright) \n         - musum_mathbfisigmahatn_sigmamathbfi\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmamathbfi  (hatc^phantom dagger_sigmamathbfi) creation (annihilation) operator a spin sigma electron on site mathbfi in the lattice, and hatn_sigmamathbfi = hatc^dagger_sigmamathbfi hatc^phantom dagger_sigmamathbfi is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site mathbfi is given by hatX_mathbfi  (hatP_mathbfi), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 25, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_square_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"Nrv\"] = Nrv\n        metadata[\"maxiter\"] = maxiter\n        metadata[\"tol\"] = tol\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n        metadata[\"hmc_iters\"] = 0.0\n        metadata[\"reflection_iters\"] = 0.0\n        metadata[\"swap_iters\"] = 0.0\n        metadata[\"measurement_iters\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs   = [[0.0, 0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the x-direction.\n        phonon_x = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add x-direction optical ssh phonon to electron-phonon model.\n        phonon_x_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_x\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the y-direction.\n        phonon_y = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add y-direction optical ssh phonon to electron-phonon model.\n        phonon_y_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_y\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_x_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_x_id, phonon_x_id),\n            bond = bond_px,\n            α_mean = α\n        )\n\n        # Add x-direction optical SSH coupling to the electron-phonon model.\n        ossh_x_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_x_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_y_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_y_id, phonon_y_id),\n            bond = bond_py,\n            α_mean = α\n        )\n\n        # Add y-direction optical SSH coupling to the electron-phonon model.\n        ossh_y_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_y_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (phonon_x_id, phonon_x_id), (phonon_y_id, phonon_y_id),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id),\n                (bond_px_id, bond_py_id),\n            ]\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C4 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C4\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, +1.0im, -1.0, -1.0im],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C2 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C2\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, -1.0, +1.0, -1.0],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = update + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 9,\n        delimiter = \", \"\n    )\n\n    # Calculate C4 BOW q=(π,π) correlation ratio.\n    Rbow, ΔRbow = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"BOW_C4\",\n        type = \"equal-time\",\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2, L÷2+1),\n            (L÷2-1, L÷2), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rbow_mean_real\"] = real(Rbow)\n    metadata[\"Rbow_mean_imag\"] = imag(Rbow)\n    metadata[\"Rbow_std\"] = ΔRbow\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"#SmoQyElPhQMC","page":"Home","title":"SmoQyElPhQMC","text":"Documentation for SmoQyElPhQMC.\n\nThe SmoQyElPhQMC package is part of SmoQySuite, and is a package that extends the functionality of the SmoQyDQMC package. Specifically, it allows for near linear scaling quantum Monte Carlo simulations of spin-symmetric electron-phonon models, absent any Hubbard interactions. This package implements a modified version of the algorithm introduced in this article:\n\n@article{PhysRevE.105.065302,\n  title = {Fast and scalable quantum Monte Carlo simulations of electron-phonon models},\n  author = {Cohen-Stead, Benjamin and Bradley, Owen and Miles, Cole and Batrouni, George and Scalettar, Richard and Barros, Kipton},\n  journal = {Phys. Rev. E},\n  volume = {105},\n  issue = {6},\n  pages = {065302},\n  numpages = {22},\n  year = {2022},\n  month = {Jun},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.105.065302},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.105.065302}\n}\n\nA more detailed description of the algorithms used in this package will appear in a future publication.","category":"section"},{"location":"#Funding","page":"Home","title":"Funding","text":"The development of this package was supported by the National Science Foundation under Award number OAC-2410280 and the Simons Foundation.","category":"section"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"section"},{"location":"examples/bssh_square/","page":"Bond Su-Schrieffer-Heeger Square","title":"Bond Su-Schrieffer-Heeger Square","text":"Download this example as a Julia script.","category":"section"},{"location":"examples/bssh_square/#Bond-Su-Schrieffer-Heeger-Square","page":"Bond Su-Schrieffer-Heeger Square","title":"Bond Su-Schrieffer-Heeger Square","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_langle ijrangleleft(frac12MhatP_langle ijrangle^2+frac12MOmega^2hatX_langle ijrangle^2right) \n         - sum_langle ijranglesigmaleftt-alphahatX_langle ijranglerightleft(hatc_sigmai^daggerhatc_sigmaj^phantomdagger+hatc_sigmaj^daggerhatc_sigmai^phantomdaggerright)-musum_isigmahatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and j is given by hatX_langle ij rangle  (hatP_langle ij rangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyElPhQMC\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    Nt = 24, # Number of time-steps in HMC update.\n    Nrv = 10, # Number of random vectors used to estimate fermionic correlation functions.\n    tol = 1e-10, # CG iterations tolerance.\n    maxiter = 10_000, # Maximum number of CG iterations.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_square_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 100),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"Nrv\"] = Nrv\n        metadata[\"maxiter\"] = maxiter\n        metadata[\"tol\"] = tol\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n        metadata[\"hmc_iters\"] = 0.0\n        metadata[\"reflection_iters\"] = 0.0\n        metadata[\"swap_iters\"] = 0.0\n        metadata[\"measurement_iters\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs   = [[0.0, 0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the x-direction.\n        phonon_x = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add x-direction optical ssh phonon to electron-phonon model.\n        phonon_x_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_x\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the y-direction.\n        phonon_y = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add y-direction optical ssh phonon to electron-phonon model.\n        phonon_y_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_y\n        )\n\n        # Define frozen phonon mode with infinite mass.\n        fphonon = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω,\n            M = Inf # Set phonon mass to infinity.\n        )\n\n        # Add frozen phonon mode to model.\n        fphonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = fphonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅X .\n        bssh_coupling_x = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_x_id),\n            bond = bond_px,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_x_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling_x,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅Y .\n        bssh_coupling_y = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_y_id),\n            bond = bond_py,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_y_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling_y,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (phonon_x_id, phonon_x_id), (phonon_y_id, phonon_y_id),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id),\n                (bond_px_id, bond_py_id),\n            ]\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C4 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C4\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, +1.0im, -1.0, -1.0im],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C2 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C2\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, -1.0, +1.0, -1.0],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize fermion determinant matrix. Also set the default tolerance and max iteration count\n    # used in conjugate gradient (CG) solves of linear systems involving this matrix.\n    fermion_det_matrix = SymFermionDetMatrix(\n        fermion_path_integral,\n        maxiter = maxiter, tol = tol\n    )\n\n    # Initialize pseudofermion field calculator.\n    pff_calculator = PFFCalculator(electron_phonon_parameters, fermion_det_matrix)\n\n    # Initialize KPM preconditioner.\n    preconditioner = KPMPreconditioner(fermion_det_matrix, rng = rng)\n\n    # Initialize Green's function estimator for making measurements.\n    greens_estimator = GreensEstimator(fermion_det_matrix, model_geometry)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAPFFHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, iters) = reflection_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"reflection_iters\"] += iters\n\n        # Perform a swap update.\n        (accepted, iters) = swap_update!(\n            electron_phonon_parameters, pff_calculator,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            preconditioner = preconditioner,\n            rng = rng, tol = tol, maxiter = maxiter\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Record the number of CG iterations performed for the reflection update.\n        metadata[\"swap_iters\"] += iters\n\n        # Perform an HMC update.\n        (accepted, iters) = hmc_update!(\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_det_matrix = fermion_det_matrix,\n            pff_calculator = pff_calculator,\n            preconditioner = preconditioner,\n            tol_action = tol, tol_force = sqrt(tol), maxiter = maxiter,\n            rng = rng,\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Record the average number of iterations per CG solve for hmc update.\n        metadata[\"hmc_iters\"] += iters\n\n        # Make measurements.\n        iters = make_measurements!(\n            measurement_container, fermion_det_matrix, greens_estimator,\n            model_geometry = model_geometry,\n            fermion_path_integral = fermion_path_integral,\n            tight_binding_parameters = tight_binding_parameters,\n            electron_phonon_parameters = electron_phonon_parameters,\n            preconditioner = preconditioner,\n            tol = tol, maxiter = maxiter,\n            rng = rng\n        )\n\n        # Record the average number of iterations per CG solve for measurements.\n        metadata[\"measurement_iters\"] += iters\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = update + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Calculate average number of CG iterations.\n    metadata[\"hmc_iters\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_iters\"] /= (N_measurements + N_therm)\n    metadata[\"swap_iters\"] /= (N_measurements + N_therm)\n    metadata[\"measurement_iters\"] /= N_measurements\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 9,\n        delimiter = \", \"\n    )\n\n    # Calculate C4 BOW q=(π,π) correlation ratio.\n    Rbow, ΔRbow = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"BOW_C4\",\n        type = \"equal-time\",\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2, L÷2+1),\n            (L÷2-1, L÷2), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rbow_mean_real\"] = real(Rbow)\n    metadata[\"Rbow_mean_imag\"] = imag(Rbow)\n    metadata[\"Rbow_std\"] = ΔRbow\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"}]
}
